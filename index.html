<!-- ********************************************************************** -->
<!--                                                                        -->
<!--  index.html                                        TTTTTTTT SSSSSSS II -->
<!--                                                       TT    SS      II -->
<!--  By: st93642@students.tsi.lv                          TT    SSSSSSS II -->
<!--                                                       TT         SS II -->
<!--  Created: Jan 25 2026 15:37 st93642                   TT    SSSSSSS II -->
<!--  Updated: Jan 25 2026 15:37 st93642                                    -->
<!--                                                                        -->
<!--   Transport and Telecommunication Institute - Riga, Latvia             -->
<!--                       https://tsi.lv                                   -->
<!-- ********************************************************************** -->


<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Comprehensive C++ Interview Questions Quiz</title>
    <style>
        :root {
            --primary-color: #3498db;
            --secondary-color: #2980b9;
            --success-color: #2ecc71;
            --danger-color: #e74c3c;
            --light-color: #ecf0f1;
            --dark-color: #2c3e50;
            --text-color: #333;
            --text-light: #fff;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            background-color: #f5f5f5;
            padding: 20px;
            transition: background-color 0.3s, color 0.3s;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
            background-color: var(--primary-color);
            color: var(--text-light);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .quiz-container {
            background-color: var(--text-light);
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 30px;
            margin-bottom: 20px;
        }

        .question-container {
            display: none;
        }

        .question-container.active {
            display: block;
        }

        .question {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 20px;
            color: var(--dark-color);
            white-space: pre-wrap;
        }

        .options {
            margin-bottom: 20px;
        }

        .option {
            background-color: var(--light-color);
            border: 2px solid #ddd;
            border-radius: 5px;
            padding: 15px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            display: flex;
            align-items: center;
        }

        .option:hover {
            background-color: #ddd;
            border-color: var(--primary-color);
        }

        .option.selected {
            background-color: var(--primary-color);
            color: var(--text-light);
            border-color: var(--secondary-color);
        }

        .option input {
            margin-right: 15px;
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .short-answer-input {
            width: 100%;
            padding: 15px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 1rem;
            margin-bottom: 10px;
        }

        .navigation {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 30px;
        }

        .nav-buttons {
            display: flex;
            gap: 10px;
        }

        button {
            background-color: var(--primary-color);
            color: var(--text-light);
            border: none;
            border-radius: 5px;
            padding: 10px 20px;
            cursor: pointer;
            font-size: 1rem;
            transition: background-color 0.3s;
            font-weight: bold;
        }

        button:hover {
            background-color: var(--secondary-color);
        }

        button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }

        .progress {
            text-align: center;
            margin: 20px 0;
            font-weight: bold;
            color: var(--dark-color);
        }

        .question-nav {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 5px;
            margin: 20px 0;
            max-height: 200px;
            overflow-y: auto;
            padding: 10px;
            background: #eee;
            border-radius: 5px;
        }

        .question-nav button {
            min-width: 40px;
            padding: 5px 10px;
            font-size: 0.8rem;
            background-color: #ddd;
            color: #333;
        }

        .question-nav button.active {
            background-color: var(--success-color);
            color: white;
        }

        .question-nav button.answered {
            background-color: var(--primary-color);
            color: white;
        }

        .results-container {
            display: none;
            background-color: var(--text-light);
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 30px;
            margin-top: 20px;
        }

        .results-container.active {
            display: block;
        }

        .score {
            font-size: 2.5rem;
            font-weight: bold;
            text-align: center;
            margin-bottom: 20px;
            color: var(--success-color);
        }

        .result-summary {
            margin-bottom: 30px;
            padding: 15px;
            background-color: var(--light-color);
            border-radius: 5px;
        }

        .result-item {
            background-color: var(--text-light);
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 15px;
            margin-bottom: 10px;
            border-left: 4px solid var(--primary-color);
        }

        .result-item.correct {
            border-left-color: var(--success-color);
        }

        .result-item.incorrect {
            border-left-color: var(--danger-color);
        }

        .result-question {
            font-weight: bold;
            margin-bottom: 5px;
            color: var(--dark-color);
        }

        .result-answer {
            margin-left: 20px;
            color: #666;
        }

        .result-correct {
            color: var(--success-color);
            font-weight: bold;
        }

        .result-incorrect {
            color: var(--danger-color);
            font-weight: bold;
        }

        .dark-mode {
            background-color: #1a1a1a;
            color: #f0f0f0;
        }

        .dark-mode .quiz-container,
        .dark-mode .results-container,
        .dark-mode .result-item,
        .dark-mode .question-nav {
            background-color: #2d2d2d;
            color: #f0f0f0;
        }
        
        .dark-mode .question {
            color: #f0f0f0;
        }

        .dark-mode .option, .dark-mode .short-answer-input {
            background-color: #3a3a3a;
            color: #f0f0f0;
            border-color: #555;
        }
        
        .dark-mode .option:hover {
            background-color: #454545;
            border-color: #6a9fb5;
        }

        .dark-mode .result-summary {
            background-color: #2d2d2d;
        }

        .category-badge {
            display: inline-block;
            background-color: var(--primary-color);
            color: var(--text-light);
            padding: 3px 8px;
            border-radius: 15px;
            font-size: 0.8rem;
            margin-left: 10px;
            font-weight: normal;
        }

        .timer {
            text-align: center;
            margin-bottom: 20px;
            font-size: 1.1rem;
        }

        .timer-display {
            font-weight: bold;
            color: var(--primary-color);
        }
        
        pre {
            background: #f4f4f4;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            border-left: 4px solid var(--primary-color);
            line-height: 1.5;
        }
        .dark-mode pre {
            background: #1e1e1e;
            color: #e8e8e8;
            border-left-color: #6a9fb5;
        }
        code {
            font-family: Consolas, "Andale Mono WT", "Andale Mono", "Lucida Console", "Lucida Sans Typewriter", "DejaVu Sans Mono", "Bitstream Vera Sans Mono", "Liberation Mono", "Nimbus Mono L", Monaco, "Courier New", Courier, monospace;
            background: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.9em;
        }
        .dark-mode code {
            background: #3a3a3a;
            color: #f0f0f0;
        }
        pre code {
            background: transparent;
            padding: 0;
        }
        
        .check-answer-btn {
            background-color: var(--success-color);
            margin-top: 15px;
            width: 100%;
            padding: 12px;
            font-size: 1.1rem;
        }
        .check-answer-btn:hover {
            background-color: #27ae60;
        }
        .check-answer-btn.checked {
            background-color: #95a5a6;
        }
        
        .answer-feedback {
            margin-top: 15px;
            padding: 15px;
            border-radius: 5px;
            display: none;
            animation: fadeIn 0.3s;
        }
        .answer-feedback.show {
            display: block;
        }
        .answer-feedback.correct {
            background-color: #d5f4e6;
            border-left: 4px solid var(--success-color);
            color: #27ae60;
        }
        .answer-feedback.incorrect {
            background-color: #fadbd8;
            border-left: 4px solid var(--danger-color);
            color: #c0392b;
        }
        .answer-feedback strong {
            display: block;
            margin-bottom: 5px;
            font-size: 1.1em;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>C++ Interview Questions Quiz</h1>
            <p>Master C++ with 1000+ Interview Questions</p>
        </header>

        <div class="quiz-container">
            <div class="timer">
                Time: <span class="timer-display" id="timer">00:00</span>
                <button id="toggleTimer" style="padding: 5px 10px; margin-left: 10px;">Pause</button>
                <button id="darkModeToggle" style="padding: 5px 10px; margin-left: 10px;">Dark Mode</button>
            </div>

            <div class="progress">
                Question <span id="current-question-idx">1</span> of <span id="total-questions-count">0</span>
            </div>

            <div class="question-nav" id="question-nav"></div>

            <div id="questions-container"></div>

            <div class="navigation">
                <div class="nav-buttons">
                    <button id="prev-btn" disabled>Previous</button>
                    <button id="next-btn">Next</button>
                </div>
                <button id="submit-btn">Submit Quiz</button>
            </div>
        </div>

        <div id="results-container" class="results-container">
            <div class="score" id="score"></div>
            <div id="score-details" style="text-align: center; margin-bottom: 20px;"></div>
            <div class="result-summary" id="result-summary"></div>
            <div id="results-list"></div>
            <div style="text-align: center; margin-top: 30px;">
                <button id="retake-btn">Retake Quiz</button>
            </div>
        </div>
    </div>

    <script>
        const quizData = [
  {
    "question": "What is the output of:\nint arr[5] = {1, 2};\ncout << arr[3];",
    "options": [
      "0",
      "Garbage",
      "3",
      "Compiler error"
    ],
    "correct": 0,
    "category": "Arrays",
    "type": "single"
  },
  {
    "question": "What is the output of: int arr[5] = {1,2,3}; cout << arr[4];",
    "options": [
      "0",
      "3",
      "Garbage value",
      "Compiler error"
    ],
    "correct": 2,
    "category": "Arrays",
    "type": "single"
  },
  {
    "question": "What is the output of:\nint arr[3] = {10, 20, 30};\ncout << arr[1];",
    "options": [
      "10",
      "20",
      "30",
      "Garbage"
    ],
    "correct": 1,
    "category": "Arrays",
    "type": "single"
  },
  {
    "question": "What is the output of:\nint arr[] = {10,20,30,40};\ncout << sizeof(arr)/sizeof(arr[0]);",
    "options": [
      "3",
      "4",
      "16",
      "Depends on system"
    ],
    "correct": 1,
    "category": "Arrays",
    "type": "single"
  },
  {
    "question": "What is the output of: int arr[3][3] = {{1,2,3},{4,5,6},{7,8,9}}; cout << arr[1][2];",
    "options": [
      "1",
      "5",
      "6",
      "9"
    ],
    "correct": 2,
    "category": "Arrays",
    "type": "single"
  },
  {
    "question": "What is the output of:\nint x = 10;\ncout << sizeof(x);",
    "options": [
      "2",
      "4",
      "8",
      "Depends on system"
    ],
    "correct": 3,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "What is the size of 'int' data type in C++?",
    "options": [
      "2 bytes",
      "4 bytes\", \n                    \"8 bytes",
      "Depends on the compiler and system",
      "Invalid option"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "Which of the following is the correct way to declare a constant in C++?",
    "options": [
      "const int x = 10;",
      "#define x 10",
      "int const x = 10;",
      "All of the above"
    ],
    "correct": 3,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "What is the size of a 'char' in C++?",
    "options": [
      "1 byte",
      "2 bytes",
      "4 bytes",
      "Depends on the system"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "Which operator is used for access to members of a structure through a pointer?",
    "options": [
      ".",
      "->",
      "*",
      "&"
    ],
    "correct": 1,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "What is the result of 5 / 2 in C++ when both are integers?",
    "options": [
      "2.5",
      "2",
      "3",
      "Error"
    ],
    "correct": 1,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "Which of the following is a valid identifier in C++?",
    "options": [
      "2variable",
      "variable_2",
      "variable 2",
      "variable-2"
    ],
    "correct": 1,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "What does 'constexpr' indicate?",
    "options": [
      "Compile-time constant",
      "Runtime constant",
      "Volatile constant",
      "Dynamic constant"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "What does 'volatile' indicate?",
    "options": [
      "Value may change unexpectedly",
      "Value is constant",
      "Value is fast",
      "Value is cached"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "What is the default value of static variables?",
    "options": [
      "Zero",
      "Garbage",
      "Null",
      "Undefined"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "Which storage class has automatic duration?",
    "options": [
      "auto",
      "static",
      "extern",
      "register"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "What is size_t used for?",
    "options": [
      "Unsigned sizes",
      "Signed sizes",
      "Pointers",
      "Characters"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "What does & operator do?",
    "options": [
      "Address-of or bitwise AND",
      "Logical AND",
      "Pointer dereference",
      "Reference creation"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "Which type represents nullptr?",
    "options": [
      "nullptr_t",
      "void*",
      "NULL",
      "0"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "Which type is for wide characters?",
    "options": [
      "wchar_t",
      "char",
      "char16_t",
      "char32_t"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "What is ptrdiff_t used for?",
    "options": [
      "Pointer differences",
      "Array sizes",
      "Integer differences",
      "Memory offsets"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "What does 'mutable' allow in const functions?",
    "options": [
      "Variable modification",
      "Function calls",
      "Object creation",
      "Memory allocation"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "Which variables persist between function calls?",
    "options": [
      "static local",
      "auto",
      "register",
      "local"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "What is single quote ' for?",
    "options": [
      "Character literal",
      "String literal",
      "Number literal",
      "Boolean literal"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "What does sizeof operator return?",
    "options": [
      "Size in bytes",
      "Size in bits",
      "Number of elements",
      "Memory address"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "What is the associativity of = operator?",
    "options": [
      "Right to left",
      "Left to right",
      "No associativity",
      "Both ways"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "What is the range of char?",
    "options": [
      "-128 to 127 or 0 to 255",
      "0 to 255",
      "-32768 to 32767",
      "Implementation defined"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "Where are global variables stored?",
    "options": [
      "Data segment",
      "Stack",
      "Heap",
      "Code segment"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "Which variables are in BSS segment?",
    "options": [
      "Uninitialized globals",
      "Initialized globals",
      "Local variables",
      "Dynamic variables"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "What is the size of long long?",
    "options": [
      "At least 8 bytes",
      "4 bytes",
      "2 bytes",
      "16 bytes"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "Which operator is for scope resolution?",
    "options": [
      "::",
      ":",
      ".",
      "->"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "What is the precedence of ++ operator?",
    "options": [
      "Highest",
      "Medium",
      "Low",
      "Lowest"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "What is 0x prefix for?",
    "options": [
      "Hexadecimal",
      "Octal",
      "Binary",
      "Decimal"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "What is R\"()\" for?",
    "options": [
      "Raw string literal",
      "Regular expression",
      "Repeat string",
      "Reference string"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "What suffix makes a literal unsigned?",
    "options": [
      "U or u",
      "S or s",
      "I or i",
      "N or n"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "Where are local variables stored?",
    "options": [
      "Stack",
      "Heap",
      "Data segment",
      "Code segment"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "What does nullptr represent?",
    "options": [
      "Null pointer",
      "Zero",
      "Null character",
      "Empty string"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "Which type is for floating-point?",
    "options": [
      "float, double, long double",
      "real",
      "decimal",
      "numeric"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "What is the scope of global variables?",
    "options": [
      "Entire program",
      "Current file",
      "Current function",
      "Current block"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "How must const variables be initialized?",
    "options": [
      "At declaration",
      "Later in code",
      "Auto-initialized",
      "Not required"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "Which operator cannot be overloaded?",
    "options": [
      "?: (ternary)",
      "+",
      "-",
      "<<"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "What does 'noexcept' specify?",
    "options": [
      "No exceptions thrown",
      "No exceptions caught",
      "No error handling",
      "No try blocks"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "Which keyword creates type aliases in modern C++?",
    "options": [
      "using",
      "typedef",
      "alias",
      "define"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "What suffix makes a literal long?",
    "options": [
      "L or l",
      "G or g",
      "N or n",
      "I or i"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "Which type is smallest integer type?",
    "options": [
      "char",
      "short",
      "int",
      "long"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "Which keyword specifies external linkage?",
    "options": [
      "extern",
      "external",
      "global",
      "public"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "What happens to uninitialized global variables?",
    "options": [
      "Zero-initialized",
      "Garbage values",
      "Compilation error",
      "Runtime error"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "Which keyword is used to prevent inheritance in C++11?",
    "options": [
      "final",
      "sealed",
      "static",
      "const"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "What is \\n in string literal?",
    "options": [
      "Newline character",
      "Null character",
      "Number",
      "Name"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "What is the lifetime of static variables?",
    "options": [
      "Program lifetime",
      "Function lifetime",
      "Block lifetime",
      "Dynamic"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "Which keyword ensures method overriding?",
    "options": [
      "override",
      "virtual",
      "final",
      "abstract"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "What is the size of wchar_t?",
    "options": [
      "Implementation defined",
      "1 byte",
      "2 bytes",
      "4 bytes"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "What does constexpr variable mean?",
    "options": [
      "Compile-time constant",
      "Runtime constant",
      "Variable constant",
      "Dynamic constant"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "What does 'static_assert' do?",
    "options": [
      "Compile-time assertion",
      "Runtime assertion",
      "Debug assertion",
      "Test assertion"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "What is register storage class hint?",
    "options": [
      "Store in CPU register",
      "Store in RAM",
      "Store on disk",
      "Store in cache"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "Which variables have static storage duration?",
    "options": [
      "Global and static",
      "Local",
      "Automatic",
      "Dynamic"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "What does 'thread_local' specify?",
    "options": [
      "Thread-specific storage",
      "Local scope",
      "Stack storage",
      "Heap storage"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "What is the output of: int arr[3] = {1,2,3}; printf(\"%d",
    "options": [
      "0",
      "3",
      "Garbage value",
      "Compiler error"
    ],
    "correct": 2,
    "category": "C Arrays",
    "type": "single"
  },
  {
    "question": "Which of the following is true about arrays in C?",
    "options": [
      "Array index starts from 0",
      "Array size must be constant",
      "Array elements are stored contiguously",
      "All of the above"
    ],
    "correct": 3,
    "category": "C Arrays",
    "type": "single"
  },
  {
    "question": "Which of the following is true about arrays of pointers in C?",
    "options": [
      "Can store addresses of different variables",
      "Enable efficient memory management",
      "Support dynamic data structures",
      "All of the above"
    ],
    "correct": 3,
    "category": "C Arrays",
    "type": "single"
  },
  {
    "question": "Which of the following is true about pointer arrays in C?",
    "options": [
      "Array of pointer variables",
      "Can store different data type addresses",
      "Enable flexible data structures",
      "All of the above"
    ],
    "correct": 3,
    "category": "C Arrays",
    "type": "single"
  },
  {
    "question": "Which of the following is true about multidimensional arrays in C?",
    "options": [
      "Arrays of arrays",
      "Row-major ordering",
      "Complex memory layout",
      "All of the above"
    ],
    "correct": 3,
    "category": "C Arrays",
    "type": "single"
  },
  {
    "question": "What is the output of the following C code?\n#include <stdio.h>\nint main() {\n    int a = 5, b = 2;\n    printf(\"%d",
    "options": [
      "2.5",
      "2",
      "3",
      "Compiler error"
    ],
    "correct": 1,
    "category": "C Basics",
    "type": "single"
  },
  {
    "question": "Which of the following is not a valid C data type?",
    "options": [
      "int",
      "float",
      "boolean",
      "char"
    ],
    "correct": 2,
    "category": "C Basics",
    "type": "single"
  },
  {
    "question": "What is the size of 'char' data type in C?",
    "options": [
      "1 byte",
      "2 bytes",
      "4 bytes",
      "Depends on compiler"
    ],
    "correct": 0,
    "category": "C Basics",
    "type": "single"
  },
  {
    "question": "What is the output of: printf(\"%d",
    "options": [
      "2",
      "4",
      "8",
      "Depends on system"
    ],
    "correct": 3,
    "category": "C Basics",
    "type": "single"
  },
  {
    "question": "Which of the following is true about best practices in C?",
    "options": [
      "Code readability",
      "Memory management",
      "Error handling",
      "All of the above"
    ],
    "correct": 3,
    "category": "C Best Practices",
    "type": "single"
  },
  {
    "question": "Which of the following is not a valid C loop?",
    "options": [
      "for",
      "while",
      "do-while",
      "until"
    ],
    "correct": 3,
    "category": "C Control Structures",
    "type": "single"
  },
  {
    "question": "Which of the following is true about unions in C?",
    "options": [
      "Members share same memory",
      "Size equals largest member",
      "Can store only one member at a time",
      "All of the above"
    ],
    "correct": 3,
    "category": "C Data Structures",
    "type": "single"
  },
  {
    "question": "Which of the following is true about bit fields in C?",
    "options": [
      "Enable memory optimization",
      "Specify exact bit widths",
      "Useful for hardware registers",
      "All of the above"
    ],
    "correct": 3,
    "category": "C Data Structures",
    "type": "single"
  },
  {
    "question": "Which of the following is true about enums in C?",
    "options": [
      "Defines named integer constants",
      "Improves code readability",
      "Default values start from 0",
      "All of the above"
    ],
    "correct": 3,
    "category": "C Data Types",
    "type": "single"
  },
  {
    "question": "Which of the following is true about debugging in C?",
    "options": [
      "Uses printf() debugging",
      "Supports gdb debugger",
      "Requires manual inspection",
      "All of the above"
    ],
    "correct": 3,
    "category": "C Debugging",
    "type": "single"
  },
  {
    "question": "Which of the following is true about error handling in C?",
    "options": [
      "Uses errno variable",
      "perror() displays errors",
      "No exception handling",
      "All of the above"
    ],
    "correct": 3,
    "category": "C Error Handling",
    "type": "single"
  },
  {
    "question": "Which of the following is true about file handling in C?",
    "options": [
      "fopen() is used to open files",
      "fclose() is used to close files",
      "FILE pointer is used to access files",
      "All of the above"
    ],
    "correct": 3,
    "category": "C File Handling",
    "type": "single"
  },
  {
    "question": "Which of the following is true about functions in C?",
    "options": [
      "They can return only one value",
      "They can have default arguments",
      "They support function overloading",
      "They can be nested"
    ],
    "correct": 0,
    "category": "C Functions",
    "type": "single"
  },
  {
    "question": "Which of the following is true about recursion in C?",
    "options": [
      "Function calls itself",
      "Requires base case to terminate",
      "Can cause stack overflow",
      "All of the above"
    ],
    "correct": 3,
    "category": "C Functions",
    "type": "single"
  },
  {
    "question": "Which of the following is true about command line arguments in C?",
    "options": [
      "argc contains argument count",
      "argv contains argument values",
      "main() function can accept them",
      "All of the above"
    ],
    "correct": 3,
    "category": "C Functions",
    "type": "single"
  },
  {
    "question": "Which of the following is true about function prototypes in C?",
    "options": [
      "Declare function signature",
      "Enable type checking",
      "Support separate compilation",
      "All of the above"
    ],
    "correct": 3,
    "category": "C Functions",
    "type": "single"
  },
  {
    "question": "Which of the following is true about static functions in C?",
    "options": [
      "Accessible only within file",
      "Have internal linkage",
      "Can't be called from other files",
      "All of the above"
    ],
    "correct": 3,
    "category": "C Functions",
    "type": "single"
  },
  {
    "question": "Which of the following is true about function recursion in C?",
    "options": [
      "Function calls itself",
      "Requires termination condition",
      "Can implement complex algorithms",
      "All of the above"
    ],
    "correct": 3,
    "category": "C Functions",
    "type": "single"
  },
  {
    "question": "Which of the following is not a valid C keyword?",
    "options": [
      "sizeof",
      "typeof",
      "if",
      "else"
    ],
    "correct": 1,
    "category": "C Keywords",
    "type": "single"
  },
  {
    "question": "Which of the following is true about typedef in C?",
    "options": [
      "Creates type aliases",
      "Improves code readability",
      "Doesn't create new types",
      "All of the above"
    ],
    "correct": 3,
    "category": "C Keywords",
    "type": "single"
  },
  {
    "question": "Which of the following is true about const variables in C?",
    "options": [
      "Value cannot be modified",
      "Must be initialized",
      "Improves code safety",
      "All of the above"
    ],
    "correct": 3,
    "category": "C Keywords",
    "type": "single"
  },
  {
    "question": "Which of the following is true about volatile variables in C?",
    "options": [
      "Prevents compiler optimizations",
      "Used for memory-mapped hardware",
      "Ensures reads/writes happen",
      "All of the above"
    ],
    "correct": 3,
    "category": "C Keywords",
    "type": "single"
  },
  {
    "question": "Which function is used to allocate memory dynamically in C?",
    "options": [
      "new",
      "malloc()",
      "allocate()",
      "create()"
    ],
    "correct": 1,
    "category": "C Memory Management",
    "type": "single"
  },
  {
    "question": "Which function is used to free dynamically allocated memory in C?",
    "options": [
      "delete",
      "free()",
      "release()",
      "deallocate()"
    ],
    "correct": 1,
    "category": "C Memory Management",
    "type": "single"
  },
  {
    "question": "Which of the following is true about dynamic memory allocation in C?",
    "options": [
      "malloc() allocates memory",
      "calloc() initializes memory to zero",
      "realloc() changes memory size",
      "All of the above"
    ],
    "correct": 3,
    "category": "C Memory Management",
    "type": "single"
  },
  {
    "question": "Which of the following is true about memory leaks in C?",
    "options": [
      "Occur when allocated memory not freed",
      "Can cause program crashes",
      "Difficult to debug",
      "All of the above"
    ],
    "correct": 3,
    "category": "C Memory Management",
    "type": "single"
  },
  {
    "question": "Which of the following is true about C programming today?",
    "options": [
      "Still widely used",
      "Embedded systems development",
      "Performance-critical applications",
      "All of the above"
    ],
    "correct": 3,
    "category": "C Modern Usage",
    "type": "single"
  },
  {
    "question": "What is the output of: int x = 10; printf(\"%d",
    "options": [
      "10",
      "11",
      "9",
      "Compiler error"
    ],
    "correct": 0,
    "category": "C Operators",
    "type": "single"
  },
  {
    "question": "What is the output of: int x = 5; printf(\"%d",
    "options": [
      "5",
      "6",
      "4",
      "Compiler error"
    ],
    "correct": 1,
    "category": "C Operators",
    "type": "single"
  },
  {
    "question": "What is the output of: int x = 10; int y = 5; printf(\"%d",
    "options": [
      "2",
      "0",
      "1",
      "Compiler error"
    ],
    "correct": 0,
    "category": "C Operators",
    "type": "single"
  },
  {
    "question": "What is the output of: int x = 3; printf(\"%d",
    "options": [
      "6",
      "1",
      "2",
      "Compiler error"
    ],
    "correct": 0,
    "category": "C Operators",
    "type": "single"
  },
  {
    "question": "What is the output of: int x = 5; int y = 3; printf(\"%d",
    "options": [
      "1",
      "7",
      "0",
      "Compiler error"
    ],
    "correct": 0,
    "category": "C Operators",
    "type": "single"
  },
  {
    "question": "What is the output of: int x = 10; int y = 0; printf(\"%d",
    "options": [
      "1",
      "0",
      "10",
      "Compiler error"
    ],
    "correct": 0,
    "category": "C Operators",
    "type": "single"
  },
  {
    "question": "Which of the following is true about optimization in C?",
    "options": [
      "Compiler optimizations",
      "Manual code optimization",
      "Performance tuning",
      "All of the above"
    ],
    "correct": 3,
    "category": "C Optimization",
    "type": "single"
  },
  {
    "question": "Which of the following is true about pointers in C?",
    "options": [
      "They store memory addresses",
      "They can be used for dynamic memory allocation",
      "They enable efficient array manipulation",
      "All of the above"
    ],
    "correct": 3,
    "category": "C Pointers",
    "type": "single"
  },
  {
    "question": "Which of the following is true about pointers to functions in C?",
    "options": [
      "They store memory addresses of functions",
      "They can be used for callbacks",
      "They enable polymorphic behavior",
      "All of the above"
    ],
    "correct": 3,
    "category": "C Pointers",
    "type": "single"
  },
  {
    "question": "Which of the following is true about function pointers in C?",
    "options": [
      "Can point to different functions",
      "Enable callback mechanisms",
      "Support polymorphic behavior",
      "All of the above"
    ],
    "correct": 3,
    "category": "C Pointers",
    "type": "single"
  },
  {
    "question": "Which of the following is true about pointers to pointers in C?",
    "options": [
      "Can create multi-dimensional arrays",
      "Enable complex data structures",
      "Support indirect access",
      "All of the above"
    ],
    "correct": 3,
    "category": "C Pointers",
    "type": "single"
  },
  {
    "question": "Which of the following is true about pointer arithmetic in C?",
    "options": [
      "Depends on data type size",
      "Enables array traversal",
      "Can cause segmentation faults",
      "All of the above"
    ],
    "correct": 3,
    "category": "C Pointers",
    "type": "single"
  },
  {
    "question": "Which of the following is true about const pointers in C?",
    "options": [
      "Pointer to constant data",
      "Constant pointer",
      "Both pointer and data can be constant",
      "All of the above"
    ],
    "correct": 3,
    "category": "C Pointers",
    "type": "single"
  },
  {
    "question": "Which of the following is true about const pointers to const data in C?",
    "options": [
      "Pointer and data both constant",
      "Can't modify pointer or data",
      "Provides maximum safety",
      "All of the above"
    ],
    "correct": 3,
    "category": "C Pointers",
    "type": "single"
  },
  {
    "question": "Which of the following is true about dangling pointers in C?",
    "options": [
      "Point to freed memory",
      "Can cause undefined behavior",
      "Should be set to NULL",
      "All of the above"
    ],
    "correct": 3,
    "category": "C Pointers",
    "type": "single"
  },
  {
    "question": "Which of the following is true about wild pointers in C?",
    "options": [
      "Uninitialized pointers",
      "Can cause crashes",
      "Should be avoided",
      "All of the above"
    ],
    "correct": 3,
    "category": "C Pointers",
    "type": "single"
  },
  {
    "question": "Which of the following is true about NULL pointers in C?",
    "options": [
      "Point to address 0",
      "Should be checked before dereferencing",
      "Used to initialize pointers",
      "All of the above"
    ],
    "correct": 3,
    "category": "C Pointers",
    "type": "single"
  },
  {
    "question": "Which of the following is true about portability in C?",
    "options": [
      "Standard compliance",
      "Cross-platform development",
      "Compiler-specific features",
      "All of the above"
    ],
    "correct": 3,
    "category": "C Portability",
    "type": "single"
  },
  {
    "question": "Which of the following is not a valid C preprocessor directive?",
    "options": [
      "#include",
      "#define",
      "#import",
      "#ifdef"
    ],
    "correct": 2,
    "category": "C Preprocessor",
    "type": "single"
  },
  {
    "question": "Which of the following is true about macros in C?",
    "options": [
      "Processed by preprocessor",
      "Don't perform type checking",
      "Can improve performance",
      "All of the above"
    ],
    "correct": 3,
    "category": "C Preprocessor",
    "type": "single"
  },
  {
    "question": "Which header file is required for input/output operations in C?",
    "options": [
      "<iostream>",
      "<stdio.h>",
      "<conio.h>",
      "<input.h>"
    ],
    "correct": 1,
    "category": "C Standard Library",
    "type": "single"
  },
  {
    "question": "Which header file is required for string operations in C?",
    "options": [
      "<string>",
      "<string.h>",
      "<cstring>",
      "<str.h>"
    ],
    "correct": 1,
    "category": "C Standard Library",
    "type": "single"
  },
  {
    "question": "Which of the following is not a valid C storage class?",
    "options": [
      "auto",
      "register",
      "static",
      "volatile"
    ],
    "correct": 3,
    "category": "C Storage Classes",
    "type": "single"
  },
  {
    "question": "Which of the following is true about static variables in C?",
    "options": [
      "Retains value between function calls",
      "Has file scope when declared globally",
      "Initialized only once",
      "All of the above"
    ],
    "correct": 3,
    "category": "C Storage Classes",
    "type": "single"
  },
  {
    "question": "Which of the following is true about register variables in C?",
    "options": [
      "Suggests storing in CPU register",
      "May improve performance",
      "Can't have address taken",
      "All of the above"
    ],
    "correct": 3,
    "category": "C Storage Classes",
    "type": "single"
  },
  {
    "question": "What is the output of: char str[] = \"Hello\"; printf(\"%d",
    "options": [
      "5",
      "6",
      "10",
      "Depends on compiler"
    ],
    "correct": 1,
    "category": "C Strings",
    "type": "single"
  },
  {
    "question": "Which of the following is true about strings in C?",
    "options": [
      "Null-terminated character arrays",
      "Can be manipulated with string.h functions",
      "Don't support operator overloading",
      "All of the above"
    ],
    "correct": 3,
    "category": "C Strings",
    "type": "single"
  },
  {
    "question": "Which of the following is true about string functions in C?",
    "options": [
      "strlen() returns string length",
      "strcpy() copies strings",
      "strcat() concatenates strings",
      "All of the above"
    ],
    "correct": 3,
    "category": "C Strings",
    "type": "single"
  },
  {
    "question": "Which of the following is true about string manipulation in C?",
    "options": [
      "Uses string.h functions",
      "Requires null termination",
      "No bounds checking",
      "All of the above"
    ],
    "correct": 3,
    "category": "C Strings",
    "type": "single"
  },
  {
    "question": "Which of the following is true about structures in C?",
    "options": [
      "They can contain different data types",
      "They are passed by value to functions",
      "They don't support inheritance",
      "All of the above"
    ],
    "correct": 3,
    "category": "C Structures",
    "type": "single"
  },
  {
    "question": "Which of the following is true about arrays of structures in C?",
    "options": [
      "Can store multiple records",
      "Enable efficient data organization",
      "Support database-like operations",
      "All of the above"
    ],
    "correct": 3,
    "category": "C Structures",
    "type": "single"
  },
  {
    "question": "Which of the following is true about nested structures in C?",
    "options": [
      "Structures within structures",
      "Enable complex data modeling",
      "Support hierarchical relationships",
      "All of the above"
    ],
    "correct": 3,
    "category": "C Structures",
    "type": "single"
  },
  {
    "question": "What is the output of: int x = 5; int y = 2; printf(\"%f",
    "options": [
      "2.5",
      "2.0",
      "2",
      "Compiler error"
    ],
    "correct": 0,
    "category": "C Type Conversion",
    "type": "single"
  },
  {
    "question": "Which of the following is true about global variables in C?",
    "options": [
      "Accessible throughout program",
      "Initialized to zero by default",
      "Have external linkage",
      "All of the above"
    ],
    "correct": 3,
    "category": "C Variables",
    "type": "single"
  },
  {
    "question": "Which of the following is true about local variables in C?",
    "options": [
      "Accessible only within function",
      "Not initialized by default",
      "Have automatic storage duration",
      "All of the above"
    ],
    "correct": 3,
    "category": "C Variables",
    "type": "single"
  },
  {
    "question": "Which of the following is true about extern variables in C?",
    "options": [
      "Declares variable defined elsewhere",
      "Enables sharing between files",
      "Has external linkage",
      "All of the above"
    ],
    "correct": 3,
    "category": "C Variables",
    "type": "single"
  },
  {
    "question": "Which of the following is true about C vs C++?",
    "options": [
      "C is procedural, C++ is object-oriented",
      "C++ has additional features",
      "C is subset of C++",
      "All of the above"
    ],
    "correct": 3,
    "category": "C vs C++",
    "type": "single"
  },
  {
    "question": "Which of the following is true about C and C++ compatibility?",
    "options": [
      "C is subset of C++",
      "Most C code works in C++",
      "Some differences exist",
      "All of the above"
    ],
    "correct": 3,
    "category": "C vs C++",
    "type": "single"
  },
  {
    "question": "What is the output of: int x = 5; cout << x++ << \" \" << ++x;",
    "options": [
      "5 6",
      "6 6",
      "5 7",
      "6 7"
    ],
    "correct": 2,
    "category": "C++ Basics",
    "type": "single"
  },
  {
    "question": "What is the output of:\nint a = 10, b = 20;\nint c = (a > b) ? a : b;\ncout << c;",
    "options": [
      "10",
      "20",
      "30",
      "Compiler error"
    ],
    "correct": 1,
    "category": "Operators",
    "type": "single"
  },
  {
    "question": "Which of the following is true about C++ best practices?",
    "options": [
      "Use RAII",
      "Prefer STL",
      "Avoid raw pointers",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++ Best Practices",
    "type": "single"
  },
  {
    "question": "Which of the following is true about lambda expressions in C++?",
    "options": [
      "Anonymous functions",
      "Capture variables",
      "C++11 feature",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++ C++11",
    "type": "single"
  },
  {
    "question": "Which of the following is true about move semantics in C++?",
    "options": [
      "Transfer resources",
      "rvalue references",
      "C++11 feature",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++ C++11",
    "type": "single"
  },
  {
    "question": "Which of the following is true about auto keyword in C++?",
    "options": [
      "Type inference",
      "C++11 feature",
      "Improves readability",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++ C++11",
    "type": "single"
  },
  {
    "question": "Which of the following is true about nullptr in C++?",
    "options": [
      "Type-safe null pointer",
      "C++11 feature",
      "Replaces NULL",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++ C++11",
    "type": "single"
  },
  {
    "question": "Which of the following is true about constexpr in C++?",
    "options": [
      "Compile-time evaluation",
      "C++11 feature",
      "Improves performance",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++ C++11",
    "type": "single"
  },
  {
    "question": "Which of the following is true about range-based for loops in C++?",
    "options": [
      "C++11 feature",
      "Simplify iteration",
      "Work with containers",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++ C++11",
    "type": "single"
  },
  {
    "question": "Which of the following is true about override keyword in C++?",
    "options": [
      "Explicit overriding",
      "C++11 feature",
      "Prevents accidental overloading",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++ C++11",
    "type": "single"
  },
  {
    "question": "Which of the following is true about final keyword in C++?",
    "options": [
      "Prevents inheritance",
      "C++11 feature",
      "Prevents overriding",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++ C++11",
    "type": "single"
  },
  {
    "question": "Which of the following is true about delegating constructors in C++?",
    "options": [
      "Call other constructors",
      "C++11 feature",
      "Reduce code duplication",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++ C++11",
    "type": "single"
  },
  {
    "question": "Which of the following is true about uniform initialization in C++?",
    "options": [
      "Consistent syntax",
      "C++11 feature",
      "Uses braces",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++ C++11",
    "type": "single"
  },
  {
    "question": "Which of the following is true about variadic templates in C++?",
    "options": [
      "Variable template arguments",
      "C++11 feature",
      "Enable generic programming",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++ C++11",
    "type": "single"
  },
  {
    "question": "Which of the following is true about rvalue references in C++?",
    "options": [
      "Bind to temporary objects",
      "C++11 feature",
      "Enable move semantics",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++ C++11",
    "type": "single"
  },
  {
    "question": "Which of the following is true about constexpr functions in C++?",
    "options": [
      "Compile-time evaluation",
      "C++11 feature",
      "Improves performance",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++ C++11",
    "type": "single"
  },
  {
    "question": "Which of the following is true about decltype in C++?",
    "options": [
      "Type deduction",
      "C++11 feature",
      "Complex type inference",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++ C++11",
    "type": "single"
  },
  {
    "question": "Which of the following is true about template aliasing in C++?",
    "options": [
      "Type aliases for templates",
      "C++11 feature",
      "Simplifies complex types",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++ C++11",
    "type": "single"
  },
  {
    "question": "Which of the following is true about noexcept in C++?",
    "options": [
      "Exception specifications",
      "C++11 feature",
      "Improves performance",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++ C++11",
    "type": "single"
  },
  {
    "question": "Which of the following is true about alignas in C++?",
    "options": [
      "Memory alignment control",
      "C++11 feature",
      "Improves performance",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++ C++11",
    "type": "single"
  },
  {
    "question": "Which of the following is true about alignof in C++?",
    "options": [
      "Query alignment requirements",
      "C++11 feature",
      "Type information",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++ C++11",
    "type": "single"
  },
  {
    "question": "Which of the following is true about thread_local in C++?",
    "options": [
      "Thread-specific storage",
      "C++11 feature",
      "Thread safety",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++ C++11",
    "type": "single"
  },
  {
    "question": "Which of the following is true about C++14 features?",
    "options": [
      "Binary literals",
      "Generic lambdas",
      "Variable templates",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++ C++14",
    "type": "single"
  },
  {
    "question": "Which of the following is true about C++17 features?",
    "options": [
      "Structured bindings",
      "Fold expressions",
      "Filesystem library",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++ C++17",
    "type": "single"
  },
  {
    "question": "Which of the following is true about C++20 features?",
    "options": [
      "Concepts",
      "Modules",
      "Coroutines",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++ C++20",
    "type": "single"
  },
  {
    "question": "Which of the following is true about constructors in C++?",
    "options": [
      "They initialize objects",
      "They have same name as class",
      "They can be overloaded",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++ Constructors",
    "type": "single"
  },
  {
    "question": "Which of the following is true about copy constructors in C++?",
    "options": [
      "Initialize object with another",
      "Prevent shallow copy issues",
      "Called during object copying",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++ Constructors",
    "type": "single"
  },
  {
    "question": "Which of the following is true about C++ debugging?",
    "options": [
      "Use debuggers",
      "Assertions",
      "Logging",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++ Debugging",
    "type": "single"
  },
  {
    "question": "Which of the following is true about exception handling in C++?",
    "options": [
      "try-catch blocks",
      "throw keyword",
      "Standard exceptions",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++ Exception Handling",
    "type": "single"
  },
  {
    "question": "Which of the following is true about C++ error handling?",
    "options": [
      "Use exceptions",
      "Avoid error codes",
      "Standard exception hierarchy",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++ Exception Handling",
    "type": "single"
  },
  {
    "question": "Which of the following is true about function overloading in C++?",
    "options": [
      "Same name, different parameters",
      "Compile-time polymorphism",
      "Return type doesn't matter",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++ Functions",
    "type": "single"
  },
  {
    "question": "Which of the following is true about default arguments in C++?",
    "options": [
      "Specified from right to left",
      "Enable flexible function calls",
      "Evaluated at compile time",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++ Functions",
    "type": "single"
  },
  {
    "question": "Which of the following is true about inline functions in C++?",
    "options": [
      "Expanded at compile time",
      "Reduce function call overhead",
      "Suitable for small functions",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++ Functions",
    "type": "single"
  },
  {
    "question": "Which of the following is true about smart pointers in C++?",
    "options": [
      "Automatic memory management",
      "unique_ptr, shared_ptr",
      "Prevent memory leaks",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++ Memory Management",
    "type": "single"
  },
  {
    "question": "Which of the following is true about C++ memory management?",
    "options": [
      "Use smart pointers",
      "Avoid memory leaks",
      "RAII principle",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++ Memory Management",
    "type": "single"
  },
  {
    "question": "Which of the following is true about namespaces in C++?",
    "options": [
      "Avoid name conflicts",
      "Organize code logically",
      "using directive",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++ Namespaces",
    "type": "single"
  },
  {
    "question": "What is the output of:\nclass A { int x; public: A() { x=5; } };\nA obj;\ncout << sizeof(obj);",
    "options": [
      "0",
      "4",
      "8",
      "Depends on compiler"
    ],
    "correct": 1,
    "category": "OOP",
    "type": "single"
  },
  {
    "question": "Which of the following is true about classes in C++?",
    "options": [
      "They encapsulate data and functions",
      "They support inheritance",
      "They enable polymorphism",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++ OOP",
    "type": "single"
  },
  {
    "question": "What is the output of:\nclass Base { public: int x=5; };\nclass Der : public Base { public: int y=10; };\nDer d;\ncout << d.x + d.y;",
    "options": [
      "5",
      "10",
      "15",
      "Compiler error"
    ],
    "correct": 2,
    "category": "OOP",
    "type": "single"
  },
  {
    "question": "Which of the following is true about inheritance in C++?",
    "options": [
      "Enables code reuse",
      "Supports hierarchical relationships",
      "Can be single or multiple",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++ OOP",
    "type": "single"
  },
  {
    "question": "Which of the following is true about friend functions in C++?",
    "options": [
      "Access private members",
      "Not member functions",
      "Can be declared anywhere",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++ OOP",
    "type": "single"
  },
  {
    "question": "Which of the following is true about abstract classes in C++?",
    "options": [
      "Cannot be instantiated",
      "Have pure virtual functions",
      "Enable interfaces",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++ OOP",
    "type": "single"
  },
  {
    "question": "Which of the following is true about multiple inheritance in C++?",
    "options": [
      "Can inherit from multiple classes",
      "Can cause diamond problem",
      "Requires virtual inheritance",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++ OOP",
    "type": "single"
  },
  {
    "question": "What is the output of:\nclass A {\npublic:\n  static int count;\n  A() { count++; }\n};\nint A::count = 0;\nA a1, a2, a3;\ncout << A::count;",
    "options": [
      "0",
      "1",
      "3",
      "Compiler error"
    ],
    "correct": 2,
    "category": "OOP",
    "type": "single"
  },
  {
    "question": "Which of the following is true about static members in C++?",
    "options": [
      "Belong to class, not objects",
      "Shared by all instances",
      "Can be accessed without objects",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++ OOP",
    "type": "single"
  },
  {
    "question": "Which of the following is true about const member functions in C++?",
    "options": [
      "Don't modify object state",
      "Can be called on const objects",
      "Have const qualifier",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++ OOP",
    "type": "single"
  },
  {
    "question": "Which of the following is true about operator overloading in C++?",
    "options": [
      "Enables intuitive syntax",
      "Most operators can be overloaded",
      "Requires special functions",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++ Operator Overloading",
    "type": "single"
  },
  {
    "question": "What is the output of: int x = 10; cout << (x << 1); in C++?",
    "options": [
      "20",
      "5",
      "1",
      "Compiler error"
    ],
    "correct": 0,
    "category": "C++ Operators",
    "type": "single"
  },
  {
    "question": "What is the output of: int x = 10; cout << (x >> 1); in C++?",
    "options": [
      "5",
      "20",
      "1",
      "Compiler error"
    ],
    "correct": 0,
    "category": "C++ Operators",
    "type": "single"
  },
  {
    "question": "What is the output of: int x = 5; int y = 2; cout << (x / y); in C++?",
    "options": [
      "2.5",
      "2",
      "3",
      "Compiler error"
    ],
    "correct": 1,
    "category": "C++ Operators",
    "type": "single"
  },
  {
    "question": "What is the output of: int x = 5; int y = 3; cout << (x % y); in C++?",
    "options": [
      "2",
      "1",
      "0",
      "Compiler error"
    ],
    "correct": 0,
    "category": "C++ Operators",
    "type": "single"
  },
  {
    "question": "What is the output of: int x = 5; cout << (x = 10) + (x = 20); in C++?",
    "options": [
      "20",
      "30",
      "15",
      "Undefined behavior"
    ],
    "correct": 3,
    "category": "C++ Operators",
    "type": "single"
  },
  {
    "question": "What is the output of: int x = 10; int y = 5; cout << (x > y ? \"A\" : \"B\"); in C++?",
    "options": [
      "A",
      "B",
      "1",
      "0"
    ],
    "correct": 0,
    "category": "C++ Operators",
    "type": "single"
  },
  {
    "question": "What is the output of: int x = 5; cout << (x += 3); in C++?",
    "options": [
      "5",
      "8",
      "3",
      "Compiler error"
    ],
    "correct": 1,
    "category": "C++ Operators",
    "type": "single"
  },
  {
    "question": "What is the output of: int x = 10; cout << (x -= 3); in C++?",
    "options": [
      "10",
      "7",
      "3",
      "Compiler error"
    ],
    "correct": 1,
    "category": "C++ Operators",
    "type": "single"
  },
  {
    "question": "What is the output of: int x = 5; cout << (x *= 2); in C++?",
    "options": [
      "5",
      "10",
      "2",
      "Compiler error"
    ],
    "correct": 1,
    "category": "C++ Operators",
    "type": "single"
  },
  {
    "question": "What is the output of: int x = 10; cout << (x /= 3); in C++?",
    "options": [
      "3",
      "1",
      "0",
      "Compiler error"
    ],
    "correct": 0,
    "category": "C++ Operators",
    "type": "single"
  },
  {
    "question": "What is the output of: int x = 10; cout << (x %= 3); in C++?",
    "options": [
      "1",
      "3",
      "0",
      "Compiler error"
    ],
    "correct": 0,
    "category": "C++ Operators",
    "type": "single"
  },
  {
    "question": "What is the output of: int x = 5; cout << (x <<= 1); in C++?",
    "options": [
      "10",
      "5",
      "1",
      "Compiler error"
    ],
    "correct": 0,
    "category": "C++ Operators",
    "type": "single"
  },
  {
    "question": "What is the output of: int x = 10; cout << (x >>= 1); in C++?",
    "options": [
      "5",
      "10",
      "1",
      "Compiler error"
    ],
    "correct": 0,
    "category": "C++ Operators",
    "type": "single"
  },
  {
    "question": "What is the output of: int x = 5; cout << (x &= 3); in C++?",
    "options": [
      "1",
      "5",
      "3",
      "Compiler error"
    ],
    "correct": 0,
    "category": "C++ Operators",
    "type": "single"
  },
  {
    "question": "What is the output of: int x = 5; cout << (x |= 3); in C++?",
    "options": [
      "7",
      "5",
      "3",
      "Compiler error"
    ],
    "correct": 0,
    "category": "C++ Operators",
    "type": "single"
  },
  {
    "question": "What is the output of: int x = 5; cout << (x ^= 3); in C++?",
    "options": [
      "6",
      "5",
      "3",
      "Compiler error"
    ],
    "correct": 0,
    "category": "C++ Operators",
    "type": "single"
  },
  {
    "question": "What is the output of: int x = 10; int y = 5; cout << (x > y ? x : y); in C++?",
    "options": [
      "10",
      "5",
      "0",
      "Compiler error"
    ],
    "correct": 0,
    "category": "C++ Operators",
    "type": "single"
  },
  {
    "question": "What is the output of: int x = 10; cout << (x = x + 1); in C++?",
    "options": [
      "10",
      "11",
      "0",
      "Compiler error"
    ],
    "correct": 1,
    "category": "C++ Operators",
    "type": "single"
  },
  {
    "question": "What is the output of: int x = 10; cout << (x = x - 1); in C++?",
    "options": [
      "10",
      "9",
      "1",
      "Compiler error"
    ],
    "correct": 1,
    "category": "C++ Operators",
    "type": "single"
  },
  {
    "question": "What is the output of: int x = 10; cout << (x = x * 2); in C++?",
    "options": [
      "10",
      "20",
      "2",
      "Compiler error"
    ],
    "correct": 1,
    "category": "C++ Operators",
    "type": "single"
  },
  {
    "question": "What is the output of: int x = 10; cout << (x = x / 2); in C++?",
    "options": [
      "10",
      "5",
      "2",
      "Compiler error"
    ],
    "correct": 1,
    "category": "C++ Operators",
    "type": "single"
  },
  {
    "question": "What is the output of: int x = 10; cout << (x = x % 3); in C++?",
    "options": [
      "1",
      "3",
      "0",
      "Compiler error"
    ],
    "correct": 0,
    "category": "C++ Operators",
    "type": "single"
  },
  {
    "question": "What is the output of: int x = 5; cout << (x = x << 1); in C++?",
    "options": [
      "10",
      "5",
      "1",
      "Compiler error"
    ],
    "correct": 0,
    "category": "C++ Operators",
    "type": "single"
  },
  {
    "question": "What is the output of: int x = 10; cout << (x = x >> 1); in C++?",
    "options": [
      "5",
      "10",
      "1",
      "Compiler error"
    ],
    "correct": 0,
    "category": "C++ Operators",
    "type": "single"
  },
  {
    "question": "What is the output of: int x = 5; cout << (x = x & 3); in C++?",
    "options": [
      "1",
      "5",
      "3",
      "Compiler error"
    ],
    "correct": 0,
    "category": "C++ Operators",
    "type": "single"
  },
  {
    "question": "What is the output of: int x = 5; cout << (x = x | 3); in C++?",
    "options": [
      "7",
      "5",
      "3",
      "Compiler error"
    ],
    "correct": 0,
    "category": "C++ Operators",
    "type": "single"
  },
  {
    "question": "What is the output of: int x = 5; cout << (x = x ^ 3); in C++?",
    "options": [
      "6",
      "5",
      "3",
      "Compiler error"
    ],
    "correct": 0,
    "category": "C++ Operators",
    "type": "single"
  },
  {
    "question": "Which of the following is true about C++ optimization?",
    "options": [
      "Compiler optimizations",
      "Profile-guided optimization",
      "Manual optimization",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++ Optimization",
    "type": "single"
  },
  {
    "question": "Which of the following is true about polymorphism in C++?",
    "options": [
      "Compile-time and runtime",
      "Function and operator overloading",
      "Virtual functions",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++ Polymorphism",
    "type": "single"
  },
  {
    "question": "Which of the following is true about virtual functions in C++?",
    "options": [
      "Enable runtime polymorphism",
      "Use vtable mechanism",
      "Can be pure virtual",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++ Polymorphism",
    "type": "single"
  },
  {
    "question": "Which of the following is true about C++ portability?",
    "options": [
      "Standard compliance",
      "Cross-platform libraries",
      "Compiler compatibility",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++ Portability",
    "type": "single"
  },
  {
    "question": "Which of the following is true about RTTI in C++?",
    "options": [
      "Runtime Type Information",
      "typeid operator",
      "dynamic_cast",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++ RTTI",
    "type": "single"
  },
  {
    "question": "Which of the following is true about references in C++?",
    "options": [
      "Aliases for variables",
      "Must be initialized",
      "Cannot be reassigned",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++ References",
    "type": "single"
  },
  {
    "question": "Which of the following is true about STL in C++?",
    "options": [
      "Standard Template Library",
      "Provides containers and algorithms",
      "Generic programming",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++ STL",
    "type": "single"
  },
  {
    "question": "Which of the following is true about STL containers in C++?",
    "options": [
      "Vector, list, map, etc.",
      "Generic data structures",
      "Efficient algorithms",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++ STL",
    "type": "single"
  },
  {
    "question": "Which of the following is true about STL algorithms in C++?",
    "options": [
      "sort(), find(), etc.",
      "Work with containers",
      "Generic algorithms",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++ STL",
    "type": "single"
  },
  {
    "question": "Which of the following is true about STL iterators in C++?",
    "options": [
      "Generalized pointers",
      "Enable container traversal",
      "Support algorithms",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++ STL",
    "type": "single"
  },
  {
    "question": "Which of the following is true about templates in C++?",
    "options": [
      "Enable generic programming",
      "Function and class templates",
      "Compile-time polymorphism",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++ Templates",
    "type": "single"
  },
  {
    "question": "Which of the following is true about function templates in C++?",
    "options": [
      "Generic functions",
      "Work with different types",
      "Compile-time instantiation",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++ Templates",
    "type": "single"
  },
  {
    "question": "Which of the following is true about class templates in C++?",
    "options": [
      "Generic classes",
      "Work with different types",
      "Compile-time instantiation",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++ Templates",
    "type": "single"
  },
  {
    "question": "Which of the following is true about SFINAE in C++?",
    "options": [
      "Substitution Failure Is Not An Error",
      "Template metaprogramming",
      "Compile-time constraints",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++ Templates",
    "type": "single"
  },
  {
    "question": "What is the output of: cout << (5 + 'a'); in C++?",
    "options": [
      "5a",
      "102",
      "5",
      "a"
    ],
    "correct": 1,
    "category": "C++ Type Conversion",
    "type": "single"
  },
  {
    "question": "What is the purpose of 'auto' keyword in C++11?",
    "options": [
      "Type inference",
      "Automatic memory management",
      "Automatic variable initialization",
      "Automatic function generation"
    ],
    "correct": 0,
    "category": "C++11",
    "type": "single"
  },
  {
    "question": "What is the purpose of 'override' keyword in C++11?",
    "options": [
      "To explicitly indicate function overriding",
      "To prevent accidental overloading",
      "To improve code readability",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++11",
    "type": "single"
  },
  {
    "question": "Which of the following is true about move semantics?",
    "options": [
      "They transfer resources instead of copying",
      "They use rvalue references",
      "They improve performance for large objects",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++11",
    "type": "single"
  },
  {
    "question": "What is the purpose of 'final' keyword in C++11?",
    "options": [
      "To prevent class inheritance",
      "To prevent function overriding",
      "Both A and B",
      "To create final classes like in Java"
    ],
    "correct": 2,
    "category": "C++11",
    "type": "single"
  },
  {
    "question": "Which of the following is true about lambda expressions?",
    "options": [
      "They are anonymous functions",
      "They can capture variables from surrounding scope",
      "They were introduced in C++11",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++11",
    "type": "single"
  },
  {
    "question": "What is the purpose of 'decltype' in C++11?",
    "options": [
      "To deduce type of expressions",
      "To create type aliases",
      "To optimize template code",
      "To create new data types"
    ],
    "correct": 0,
    "category": "C++11",
    "type": "single"
  },
  {
    "question": "What is the purpose of 'noexcept' in C++11?",
    "options": [
      "To specify functions that don't throw exceptions",
      "To optimize exception handling",
      "To improve performance",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++11",
    "type": "single"
  },
  {
    "question": "What is the purpose of 'constexpr' in C++11?",
    "options": [
      "To evaluate expressions at compile time",
      "To create constant expressions",
      "To optimize code",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++11",
    "type": "single"
  },
  {
    "question": "Which of the following is true about move constructors?",
    "options": [
      "They take rvalue references as parameters",
      "They transfer resources instead of copying",
      "They are used with std::move",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++11",
    "type": "single"
  },
  {
    "question": "Which of the following is true about lambda capture modes?",
    "options": [
      "[=",
      "Invalid option",
      "Invalid option",
      "Invalid option"
    ],
    "correct": 0,
    "category": "C++11",
    "type": "single"
  },
  {
    "question": "What is the purpose of 'alignas' specifier in C++11?",
    "options": [
      "To specify memory alignment requirements",
      "To optimize memory access",
      "To improve cache performance",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++11",
    "type": "single"
  },
  {
    "question": "Which of the following is true about move assignment operators?",
    "options": [
      "They transfer resources from one object to another",
      "They take rvalue references as parameters",
      "They leave source object in valid state",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++11",
    "type": "single"
  },
  {
    "question": "Which of the following is true about perfect forwarding?",
    "options": [
      "It preserves value categories",
      "It uses std::forward",
      "It enables efficient parameter passing",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++11",
    "type": "single"
  },
  {
    "question": "What is the purpose of 'alignof' operator in C++11?",
    "options": [
      "To query alignment requirements of types",
      "To optimize memory layout",
      "To improve cache performance",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++11",
    "type": "single"
  },
  {
    "question": "Which of the following is true about variadic templates?",
    "options": [
      "They accept variable number of template arguments",
      "They use parameter packs",
      "They enable type-safe variadic functions",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++11",
    "type": "single"
  },
  {
    "question": "What is the difference between 'lvalue' and 'rvalue'?",
    "options": [
      "Lvalues have addresses, rvalues are temporary",
      "Lvalues can be assigned to, rvalues cannot",
      "Lvalues persist, rvalues are short-lived",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++11",
    "type": "single"
  },
  {
    "question": "What is the purpose of 'std::move' in C++11?",
    "options": [
      "To convert lvalues to rvalues",
      "To enable move semantics",
      "To transfer ownership of resources",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++11",
    "type": "single"
  },
  {
    "question": "What is the purpose of 'std::forward' in C++11?",
    "options": [
      "To preserve value categories in perfect forwarding",
      "To enable efficient parameter passing",
      "To work with rvalue references",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++11",
    "type": "single"
  },
  {
    "question": "Which of the following is true about template parameter packs?",
    "options": [
      "They enable variadic templates",
      "They use ... syntax",
      "They can be expanded with pack expansion",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++11",
    "type": "single"
  },
  {
    "question": "What is the purpose of 'std::make_shared' in C++11?",
    "options": [
      "To create shared_ptr objects",
      "To enable efficient memory allocation",
      "To reduce memory overhead",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++11",
    "type": "single"
  },
  {
    "question": "What is the difference between 'lvalue references' and 'rvalue references'?",
    "options": [
      "Lvalue references bind to lvalues, rvalue references bind to rvalues",
      "Lvalue references use &, rvalue references use &&",
      "Rvalue references enable move semantics",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++11",
    "type": "single"
  },
  {
    "question": "What is the purpose of 'std::enable_if' in C++11?",
    "options": [
      "To enable function templates based on conditions",
      "To implement SFINAE",
      "To provide compile-time constraints",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++11",
    "type": "single"
  },
  {
    "question": "What is the difference between 'constexpr' functions and regular functions?",
    "options": [
      "constexpr functions can be evaluated at compile time",
      "constexpr functions have restrictions on what they can do",
      "constexpr functions enable compile-time computations",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++11",
    "type": "single"
  },
  {
    "question": "What is the purpose of 'std::conditional' in C++11?",
    "options": [
      "To provide compile-time conditional type selection",
      "To implement type traits",
      "To enable template metaprogramming",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++11",
    "type": "single"
  },
  {
    "question": "What is the purpose of 'std::is_same' in C++11?",
    "options": [
      "To check if two types are the same",
      "To implement type traits",
      "To enable template metaprogramming",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++11",
    "type": "single"
  },
  {
    "question": "What is the purpose of 'std::enable_shared_from_this' in C++11?",
    "options": [
      "To enable shared_ptr creation from this pointer",
      "To prevent memory management issues",
      "To enable safe this pointer usage",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++11",
    "type": "single"
  },
  {
    "question": "What is the purpose of 'std::tuple' in C++11?",
    "options": [
      "To create heterogeneous collections",
      "To enable multiple return values",
      "To work with variadic templates",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++11",
    "type": "single"
  },
  {
    "question": "What is the purpose of 'std::array' in C++11?",
    "options": [
      "To provide fixed-size arrays with STL interface",
      "To enable bounds checking",
      "To work with STL algorithms",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++11",
    "type": "single"
  },
  {
    "question": "What is the difference between 'lvalue' and 'rvalue' references in terms of usage?",
    "options": [
      "Lvalue references bind to lvalues, rvalue references bind to rvalues",
      "Lvalue references use &, rvalue references use &&",
      "Rvalue references enable move semantics and perfect forwarding",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++11",
    "type": "single"
  },
  {
    "question": "What is the purpose of 'std::unique_ptr' in C++11?",
    "options": [
      "To provide exclusive ownership semantics",
      "To automatically manage memory",
      "To prevent memory leaks",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++11",
    "type": "single"
  },
  {
    "question": "Which of the following is true about template metaprogramming and type traits in C++11?",
    "options": [
      "Type traits provide compile-time type information",
      "They enable template metaprogramming",
      "They include utilities for type manipulation",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++11",
    "type": "single"
  },
  {
    "question": "What is the purpose of 'std::shared_ptr' in C++11?",
    "options": [
      "To provide shared ownership semantics",
      "To use reference counting for memory management",
      "To enable automatic memory cleanup",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++11",
    "type": "single"
  },
  {
    "question": "What is the purpose of 'std::weak_ptr' in C++11?",
    "options": [
      "To break circular references in shared_ptr",
      "To provide non-owning references",
      "To enable safe memory management",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++11",
    "type": "single"
  },
  {
    "question": "What is the purpose of 'decltype(auto)' in C++14?",
    "options": [
      "To deduce return types with exact cv-qualifiers",
      "To simplify template code",
      "To improve type deduction",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++14",
    "type": "single"
  },
  {
    "question": "What is the purpose of 'std::exchange' in C++14?",
    "options": [
      "To replace value and return old value",
      "To enable efficient value swapping",
      "To work with move semantics",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++14",
    "type": "single"
  },
  {
    "question": "What is the purpose of 'std::make_unique' in C++14?",
    "options": [
      "To create unique_ptr objects",
      "To prevent memory leaks",
      "To enable exception-safe memory allocation",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++14",
    "type": "single"
  },
  {
    "question": "Which of the following is true about template argument deduction for class templates?",
    "options": [
      "It was introduced in C++17",
      "It allows deducing template arguments from constructors",
      "It simplifies template usage",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++17",
    "type": "single"
  },
  {
    "question": "Which of the following is true about template argument deduction for class template constructors?",
    "options": [
      "It was introduced in C++17",
      "It allows deducing template arguments from constructors",
      "It simplifies template usage",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++17",
    "type": "single"
  },
  {
    "question": "What is the difference between 'constexpr' and 'consteval' in C++20?",
    "options": [
      "consteval requires compile-time evaluation",
      "constexpr can be runtime or compile-time",
      "consteval was introduced in C++20",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++20",
    "type": "single"
  },
  {
    "question": "What is the difference between 'constexpr' and 'consteval' functions in C++20?",
    "options": [
      "consteval requires compile-time evaluation",
      "constexpr can be runtime or compile-time",
      "consteval was introduced in C++20",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++20",
    "type": "single"
  },
  {
    "question": "What is the difference between 'constexpr' and 'consteval' in C++20 in terms of evaluation requirements?",
    "options": [
      "consteval requires compile-time evaluation",
      "constexpr can be runtime or compile-time",
      "consteval was introduced in C++20 for compile-time functions",
      "All of the above"
    ],
    "correct": 3,
    "category": "C++20",
    "type": "single"
  },
  {
    "question": "What is the output of:\nclass A {\n  int x;\npublic:\n  A(int v): x(v) {}\n  int get() { return x; }\n};\nA obj(10);\ncout << obj.get();",
    "options": [
      "0",
      "10",
      "Garbage",
      "Compiler error"
    ],
    "correct": 1,
    "category": "Constructors",
    "type": "single"
  },
  {
    "question": "Which of the following is true about copy constructors?",
    "options": [
      "They are called when objects are passed by value",
      "They take reference to same class object as parameter",
      "They are used to initialize one object with another",
      "All of the above"
    ],
    "correct": 3,
    "category": "Constructors",
    "type": "single"
  },
  {
    "question": "Which of the following is true about constructor initialization lists?",
    "options": [
      "They initialize members before constructor body",
      "They are more efficient for const members",
      "They are required for reference members",
      "All of the above"
    ],
    "correct": 3,
    "category": "Constructors",
    "type": "single"
  },
  {
    "question": "Which of the following is true about default constructors?",
    "options": [
      "They take no arguments",
      "They initialize objects with default values",
      "Compiler generates one if not defined",
      "All of the above"
    ],
    "correct": 3,
    "category": "Constructors",
    "type": "single"
  },
  {
    "question": "Which of the following is true about copy constructors vs assignment operators?",
    "options": [
      "Copy constructor initializes new object, assignment operator assigns to existing object",
      "Copy constructor takes const reference, assignment operator takes non-const reference",
      "Copy constructor is called during object creation, assignment operator during assignment",
      "All of the above"
    ],
    "correct": 3,
    "category": "Constructors",
    "type": "single"
  },
  {
    "question": "Which of the following is true about constructor delegation?",
    "options": [
      "It allows one constructor to call another",
      "It reduces code duplication",
      "It was introduced in C++11",
      "All of the above"
    ],
    "correct": 3,
    "category": "Constructors",
    "type": "single"
  },
  {
    "question": "Which of the following is not a valid C++ loop?",
    "options": [
      "for",
      "while",
      "do-while",
      "until"
    ],
    "correct": 3,
    "category": "Control Structures",
    "type": "single"
  },
  {
    "question": "What is the output of:\nfor(int i=0; i<3; i++) {\n  if(i==1) continue;\n  cout << i;\n}",
    "options": [
      "012",
      "02",
      "01",
      "12"
    ],
    "correct": 1,
    "category": "Control Structures",
    "type": "single"
  },
  {
    "question": "In a 'switch' statement, what happens if a 'break' is omitted?",
    "options": [
      "It generates a compiler error",
      "It stops after the matching case",
      "It falls through to the next case",
      "It jumps to the default case"
    ],
    "correct": 2,
    "category": "Control Structures",
    "type": "single"
  },
  {
    "question": "What is the output of:\nint x;\nif(x = 10)\n  cout << x;\nelse\n  cout << 0;",
    "options": [
      "0",
      "10",
      "Garbage",
      "Compiler error"
    ],
    "correct": 1,
    "category": "Control Structures",
    "type": "single"
  },
  {
    "question": "Which loop is guaranteed to execute at least once?",
    "options": [
      "for",
      "while",
      "do-while",
      "None of the above"
    ],
    "correct": 2,
    "category": "Control Structures",
    "type": "single"
  },
  {
    "question": "What is the output of:\nint i = 0;\ndo {\n  cout << i;\n  i++;\n} while(i < 3);",
    "options": [
      "012",
      "123",
      "0123",
      "Nothing"
    ],
    "correct": 0,
    "category": "Control Structures",
    "type": "single"
  },
  {
    "question": "What does the 'continue' statement do?",
    "options": [
      "Exits the loop",
      "Starts the next iteration of the loop",
      "Exits the current function",
      "Skips to the end of the program"
    ],
    "correct": 1,
    "category": "Control Structures",
    "type": "single"
  },
  {
    "question": "What happens after 'break' in switch?",
    "options": [
      "Exits switch",
      "Goes to next case",
      "Restarts switch",
      "Error"
    ],
    "correct": 0,
    "category": "Control Structures",
    "type": "single"
  },
  {
    "question": "Does 'break' affect outer loop?",
    "options": [
      "No",
      "Yes",
      "Sometimes",
      "Depends"
    ],
    "correct": 0,
    "category": "Control Structures",
    "type": "single"
  },
  {
    "question": "What is the correct syntax for a for loop in C++?",
    "options": [
      "for(init; condition; increment)",
      "for(condition)",
      "for init:condition",
      "for[init;cond]"
    ],
    "correct": 0,
    "category": "Control Structures",
    "type": "single"
  },
  {
    "question": "When does a while loop terminate?",
    "options": [
      "When condition is false",
      "After fixed iterations",
      "Never",
      "On break only"
    ],
    "correct": 0,
    "category": "Control Structures",
    "type": "single"
  },
  {
    "question": "Which of the following is true about if-else in C++?",
    "options": [
      "It provides essential if-else functionality",
      "It is deprecated and should not be used",
      "It is only available in C",
      "It has no practical applications"
    ],
    "correct": 0,
    "category": "Control Structures",
    "type": "single"
  },
  {
    "question": "What is required to prevent fall-through in switch?",
    "options": [
      "break statement",
      "return statement",
      "Nothing",
      "continue statement"
    ],
    "correct": 0,
    "category": "Control Structures",
    "type": "single"
  },
  {
    "question": "Which of the following is true about do-while in C++?",
    "options": [
      "It provides essential do-while functionality",
      "It is deprecated and should not be used",
      "It is only available in C",
      "It has no practical applications"
    ],
    "correct": 0,
    "category": "Control Structures",
    "type": "single"
  },
  {
    "question": "Where is 'break' valid?",
    "options": [
      "Loops and switch",
      "Only loops",
      "Only switch",
      "Anywhere"
    ],
    "correct": 0,
    "category": "Control Structures",
    "type": "single"
  },
  {
    "question": "What happens without 'break' in switch?",
    "options": [
      "Fall-through to next case",
      "Compilation error",
      "Runtime error",
      "Nothing"
    ],
    "correct": 0,
    "category": "Control Structures",
    "type": "single"
  },
  {
    "question": "What is difference between 'break' and 'continue'?",
    "options": [
      "break exits, continue skips",
      "Same behavior",
      "continue exits",
      "break skips"
    ],
    "correct": 0,
    "category": "Control Structures",
    "type": "single"
  },
  {
    "question": "What does 'continue' skip?",
    "options": [
      "Rest of current iteration",
      "Next iteration",
      "All iterations",
      "Nothing"
    ],
    "correct": 0,
    "category": "Control Structures",
    "type": "single"
  },
  {
    "question": "Can 'continue' be used in do-while?",
    "options": [
      "Yes",
      "No",
      "Only in C",
      "Only in C++"
    ],
    "correct": 0,
    "category": "Control Structures",
    "type": "single"
  },
  {
    "question": "What is alternative to 'break' for loop exit?",
    "options": [
      "return or goto",
      "continue",
      "exit()",
      "abort()"
    ],
    "correct": 0,
    "category": "Control Structures",
    "type": "single"
  },
  {
    "question": "Is 'continue' valid in nested loops?",
    "options": [
      "Yes, affects innermost",
      "No",
      "Affects all loops",
      "Error"
    ],
    "correct": 0,
    "category": "Control Structures",
    "type": "single"
  },
  {
    "question": "Can 'break' be labeled in C++?",
    "options": [
      "No, use goto instead",
      "Yes with labels",
      "Yes in C++20",
      "Never"
    ],
    "correct": 0,
    "category": "Control Structures",
    "type": "single"
  },
  {
    "question": "What does 'break' do in a loop?",
    "options": [
      "Exits the loop",
      "Skips iteration",
      "Restarts loop",
      "Pauses loop"
    ],
    "correct": 0,
    "category": "Control Structures",
    "type": "single"
  },
  {
    "question": "Can for loop have empty initialization?",
    "options": [
      "Yes, all parts are optional",
      "No, must initialize",
      "Only in C",
      "Only in C++11"
    ],
    "correct": 0,
    "category": "Control Structures",
    "type": "single"
  },
  {
    "question": "Does 'continue' affect outer loop?",
    "options": [
      "No, only current loop",
      "Yes",
      "Sometimes",
      "Always"
    ],
    "correct": 0,
    "category": "Control Structures",
    "type": "single"
  },
  {
    "question": "Is 'break' needed in last switch case?",
    "options": [
      "Optional but good practice",
      "Always required",
      "Never needed",
      "Only in C"
    ],
    "correct": 0,
    "category": "Control Structures",
    "type": "single"
  },
  {
    "question": "What happens after 'continue' in while loop?",
    "options": [
      "Checks condition",
      "Exits loop",
      "Restarts from beginning",
      "Error"
    ],
    "correct": 0,
    "category": "Control Structures",
    "type": "single"
  },
  {
    "question": "Can 'continue' be used in switch?",
    "options": [
      "No, only in loops",
      "Yes",
      "Only with break",
      "Only in C++11"
    ],
    "correct": 0,
    "category": "Control Structures",
    "type": "single"
  },
  {
    "question": "What is the difference between 'struct' and 'union'?",
    "options": [
      "Union members share the same memory, struct members have separate memory",
      "Union can store only one member at a time",
      "Union size is equal to largest member size",
      "All of the above"
    ],
    "correct": 3,
    "category": "Data Structures",
    "type": "single"
  },
  {
    "question": "What is the output of:\nbool b = true;\ncout << sizeof(b);",
    "options": [
      "1",
      "4",
      "8",
      "Depends on compiler"
    ],
    "correct": 0,
    "category": "Data Types",
    "type": "single"
  },
  {
    "question": "What is the output of: cout << sizeof(bool);",
    "options": [
      "1",
      "4",
      "8",
      "Depends on compiler"
    ],
    "correct": 0,
    "category": "Data Types",
    "type": "single"
  },
  {
    "question": "What is the output of: bool b = true; cout << sizeof(b);",
    "options": [
      "1",
      "4",
      "8",
      "Depends on compiler"
    ],
    "correct": 0,
    "category": "Data Types",
    "type": "single"
  },
  {
    "question": "How to declare a static array of real numbers correctly?",
    "options": [
      "float arr[10];",
      "const double n=10; double arr[n];",
      "int n=10; float arr[n]",
      "const int n=10; double arr[n];"
    ],
    "correct": [
      0,
      3
    ],
    "category": "Exam",
    "type": "multiple"
  },
  {
    "question": "int arr[5]={100, 99, -5, 1, 10}; What is the value of arr[4]?",
    "options": [
      "Invalid option",
      "Invalid option",
      "Invalid option",
      "Invalid option"
    ],
    "correct": 0,
    "category": "Exam",
    "type": "shortanswer"
  },
  {
    "question": "What is the value of the variable `a` after the following fragment? ``` int a = 12, b = a / 5; if (a < 0) b += 1; a = b; ```",
    "options": [
      "2.4",
      "3.4",
      "12",
      "2"
    ],
    "correct": [],
    "category": "Exam",
    "type": "multiple"
  },
  {
    "question": "What will be printed on the screen? ` int a[3][3] = { {1, 2, 3}, {4, 5, 6}, {7, 8, 9} }; int sum = 0; for(int i = 0; i < 3; i++) for(int j = 0; j <= i; j++) sum += a[i][j]; cout << sum; `",
    "options": [
      "19",
      "45",
      "21",
      "34"
    ],
    "correct": [
      3
    ],
    "category": "Exam",
    "type": "multiple"
  },
  {
    "question": "What is the correct syntax of an if statement? Note. Square brackets delimit optional parts.",
    "options": [
      "if expression: statement_1 [else statement_2]",
      "if (expression) statement_1 else statement_2",
      "if (expression) statement_1 [else statement_2]",
      "if (statement) expression_1 [else expression_2]"
    ],
    "correct": [
      2
    ],
    "category": "Exam",
    "type": "multiple"
  },
  {
    "question": "How array elements are indexed?",
    "options": [
      "Starting from any number.",
      "Starting from 0 .",
      "Starting from 1 .",
      "Indexing pattern is specified when declaring an array."
    ],
    "correct": [
      1
    ],
    "category": "Exam",
    "type": "multiple"
  },
  {
    "question": "What is the value of `*p` after the following fragment? ``` int *pa = new int(10); (*pa)++; ```",
    "options": [
      "This fragment would not compile.",
      "Impossible to tell.",
      "11",
      "10"
    ],
    "correct": [
      2
    ],
    "category": "Exam",
    "type": "multiple"
  },
  {
    "question": "What is the correct syntax of a dowhile statement?",
    "options": [
      "do statement while (expression);",
      "while (expression) do statement",
      "do expression while (statement);",
      "while expression do statement"
    ],
    "correct": [
      0
    ],
    "category": "Exam",
    "type": "multiple"
  },
  {
    "question": "Which code fragment (or fragments) match given block-diagram?",
    "options": [
      "int a; for (int i = 1; i <= 5; i++) { cin >> a; if (a < 0) continue; cout << sqrt(a) << endl; }",
      "int a; int i = 1; if (i <= 5) cin >> a; if (a < 0) i++; else cout << sqrt(a);",
      "int a; int i = 1; for (int i = 1; i <= 5;) { cin >> a; if (a < 0) i++; else { cout << sqrt(a) << endl; i++; } }",
      "int a; int i = 1; for (int i = 1; i <= 5; i++) { cin >> a; if (a < 0) i++; else { cout << sqrt(a) << endl; i++; } }"
    ],
    "correct": [
      0
    ],
    "category": "Exam",
    "type": "multiple"
  },
  {
    "question": "What will the value of the variable `a` be after the next fragment? ``` int a = 16; while (a % 4 != 3) a += a % 5; ```",
    "options": [
      "Invalid option",
      "Invalid option",
      "Invalid option",
      "Invalid option"
    ],
    "correct": 0,
    "category": "Exam",
    "type": "shortanswer"
  },
  {
    "question": "What characters can be used in comments?",
    "options": [
      "Punctuation characters",
      "Non-ASCII Unicode characters (those with codes greater than 127)",
      "Latin alphabet letters",
      "Invalid option"
    ],
    "correct": 0,
    "category": "Exam",
    "type": "multiple"
  },
  {
    "question": "How many elements are in the array declared as `int arr[5][6]` ?",
    "options": [
      "65",
      "56",
      "30",
      "11"
    ],
    "correct": [
      2
    ],
    "category": "Exam",
    "type": "multiple"
  },
  {
    "question": "What will be printed on the screen? ` int arr[2][3] = {{1,2,3},{4,5,6}}; cout << arr[1][2]; `",
    "options": [
      "6",
      "5",
      "2",
      "3"
    ],
    "correct": [
      0
    ],
    "category": "Exam",
    "type": "multiple"
  },
  {
    "question": "What can be size expression when declaring a static array?",
    "options": [
      "Positive integer constant",
      "Integer constant",
      "Any variable",
      "Integer variable"
    ],
    "correct": [
      0
    ],
    "category": "Exam",
    "type": "multiple"
  },
  {
    "question": "Which of the following statements would allocate an array of 10 integers in dynamic memory?",
    "options": [
      "int arr = new int[10];",
      "int* arr = new int[10];",
      "int* arr = int(10);",
      "int* arr = new int(10);"
    ],
    "correct": [
      1
    ],
    "category": "Exam",
    "type": "multiple"
  },
  {
    "question": "Which of the following fragments would produce the sequence `2 7 12 17 22 27 ` for i values?",
    "options": [
      "i=2; do i=5; while i<=27;",
      "i=2; while (i<27) do i:=i+5;",
      "i==2; for (i=2; i<27; i+=5);",
      "no correct answer"
    ],
    "correct": [],
    "category": "Exam",
    "type": "multiple"
  },
  {
    "question": "Which loops bodies will be executed exactly two times?",
    "options": [
      "int i = 100; while (i != 98) i++;",
      "int i = 0; while (i < 2) i++;",
      "int i = 2; while (i >= 1) --i;",
      "int i = 0; while (i < 2) i--;"
    ],
    "correct": [
      1
    ],
    "category": "Exam",
    "type": "multiple"
  },
  {
    "question": "Which of the expressions results in the value pointed to by the pointer `ptr` ?",
    "options": [
      "$ptr",
      "#ptr",
      "&ptr",
      "*ptr"
    ],
    "correct": [
      3
    ],
    "category": "Exam",
    "type": "multiple"
  },
  {
    "question": "In which case(s) the body of the loop will never be executed?",
    "options": [
      "for (i = 0; i > 3; --i) {}",
      "for (i = 3; i > 0; i--) {}",
      "for (i = 1; i < 3; ++i) {}",
      "for (i = 3; i < 0; i++) {}"
    ],
    "correct": [
      0,
      3
    ],
    "category": "Exam",
    "type": "multiple"
  },
  {
    "question": "Which of the statements is/are syntactically correct?",
    "options": [
      "if (b > a) { max = b else max = a};",
      "if (b > a) max == b; else max == a;",
      "if (b > a) max = b; else max = a;",
      "max = (b > a) ? b : a;"
    ],
    "correct": [
      3
    ],
    "category": "Exam",
    "type": "multiple"
  },
  {
    "question": "Which of the `cout` statements in the following program will produce an error? ``` #include<iostream> using namespace std; int main() { cout << i; // Nr 1 for (int i = 1; i <= 3; i++) { { cout << i; // Nr 2 } cout << i; // Nr 3 } } cout << i; // Nr 4 ```",
    "options": [
      "4",
      "2",
      "3",
      "1"
    ],
    "correct": [
      3
    ],
    "category": "Exam",
    "type": "multiple"
  },
  {
    "question": "What is the purpose of this loop if the array `arr` has size `[3][4]` ? ` for(int i = 0; i < 3; i++) for(int j = 0; j < 4; j++) cout << arr[i][j]; `",
    "options": [
      "It prints only the first column",
      "It prints all elements of the array",
      "It prints the diagonal of the array",
      "It prints only the first row"
    ],
    "correct": [
      1
    ],
    "category": "Exam",
    "type": "multiple"
  },
  {
    "question": "What is the output of:\ntry {\n  throw 42;\n} catch(int e) {\n  cout << e;\n}",
    "options": [
      "0",
      "42",
      "Error",
      "Nothing"
    ],
    "correct": 1,
    "category": "Exception Handling",
    "type": "single"
  },
  {
    "question": "Which of the following is not a valid C++ exception handling keyword?",
    "options": [
      "try",
      "catch",
      "finally",
      "throw"
    ],
    "correct": 2,
    "category": "Exception Handling",
    "type": "single"
  },
  {
    "question": "What is the difference between 'throw' and 'throw;'?",
    "options": [
      "throw; rethrows current exception, throw throws new exception",
      "throw; is used in catch blocks",
      "throw; doesn't require exception object",
      "All of the above"
    ],
    "correct": 3,
    "category": "Exception Handling",
    "type": "single"
  },
  {
    "question": "Which header file is required for exception handling?",
    "options": [
      "<exception>",
      "<stdexcept>",
      "<error>",
      "Both A and B"
    ],
    "correct": 3,
    "category": "Exception Handling",
    "type": "single"
  },
  {
    "question": "Which of the following is true about exception specifications?",
    "options": [
      "They specify what exceptions a function can throw",
      "They were deprecated in C++11",
      "They can be used with noexcept",
      "All of the above"
    ],
    "correct": 3,
    "category": "Exception Handling",
    "type": "single"
  },
  {
    "question": "Which keyword is used to handle exceptions in C++?",
    "options": [
      "try",
      "catch",
      "throw",
      "All of the above"
    ],
    "correct": 3,
    "category": "Exception Handling",
    "type": "single"
  },
  {
    "question": "What happens if an exception is thrown but not caught?",
    "options": [
      "The program continues normally",
      "The program terminates with an error",
      "The exception is ignored",
      "The compiler fixes it"
    ],
    "correct": 1,
    "category": "Exception Handling",
    "type": "single"
  },
  {
    "question": "How to create custom exception?",
    "options": [
      "Inherit from std::exception",
      "Use throw keyword",
      "Use catch keyword",
      "Use error codes"
    ],
    "correct": 0,
    "category": "Exceptions",
    "type": "single"
  },
  {
    "question": "What does 'throw' do?",
    "options": [
      "Raises an exception",
      "Catches exception",
      "Handles exception",
      "Prevents exception"
    ],
    "correct": 0,
    "category": "Exceptions",
    "type": "single"
  },
  {
    "question": "Which of the following is true about try-catch in C++?",
    "options": [
      "It provides essential try-catch functionality",
      "It is deprecated and should not be used",
      "It is only available in C",
      "It has no practical applications"
    ],
    "correct": 0,
    "category": "Exceptions",
    "type": "single"
  },
  {
    "question": "Which header file is required for file I/O operations?",
    "options": [
      "<iostream>",
      "<fstream>",
      "<file.h>",
      "<stdio.h>"
    ],
    "correct": 1,
    "category": "File Handling",
    "type": "single"
  },
  {
    "question": "What is the output of:\nint add(int a, int b) { return a+b; }\ndouble add(double a, double b) { return a+b; }\ncout << add(5, 10);",
    "options": [
      "15",
      "15.0",
      "Compiler error",
      "Ambiguous"
    ],
    "correct": 0,
    "category": "Functions",
    "type": "single"
  },
  {
    "question": "What is the default return type of a function in C++?",
    "options": [
      "void",
      "int",
      "float",
      "double"
    ],
    "correct": 1,
    "category": "Functions",
    "type": "single"
  },
  {
    "question": "Which of the following is true about inline functions?",
    "options": [
      "They are expanded at compile time",
      "They reduce function call overhead",
      "They should be used for small, frequently called functions",
      "All of the above"
    ],
    "correct": 3,
    "category": "Functions",
    "type": "single"
  },
  {
    "question": "Which of the following is true about function overloading?",
    "options": [
      "Functions must have different parameter lists",
      "Functions can have different return types",
      "Functions must have the same name",
      "Both A and C"
    ],
    "correct": 3,
    "category": "Functions",
    "type": "single"
  },
  {
    "question": "What is the difference between 'pass by value' and 'pass by reference'?",
    "options": [
      "Pass by value creates copy, pass by reference uses original",
      "Pass by reference is faster for large objects",
      "Pass by value doesn't modify original, pass by reference can",
      "All of the above"
    ],
    "correct": 3,
    "category": "Functions",
    "type": "single"
  },
  {
    "question": "Which of the following is true about default arguments?",
    "options": [
      "They must be specified from right to left",
      "They can be overridden in derived classes",
      "They are evaluated at compile time",
      "All of the above"
    ],
    "correct": 0,
    "category": "Functions",
    "type": "single"
  },
  {
    "question": "What is the difference between 'pass by value' and 'pass by const reference'?",
    "options": [
      "Pass by const reference avoids copying",
      "Pass by const reference can't modify original",
      "Pass by const reference is more efficient for large objects",
      "All of the above"
    ],
    "correct": 3,
    "category": "Functions",
    "type": "single"
  },
  {
    "question": "Which of the following is true about default arguments in functions?",
    "options": [
      "They must be specified from rightmost parameter",
      "They can be overridden in derived classes",
      "They are evaluated at runtime",
      "Both A and B"
    ],
    "correct": 0,
    "category": "Functions",
    "type": "single"
  },
  {
    "question": "What is a recursive function?",
    "options": [
      "A function that calls another function",
      "A function that calls itself",
      "A function that has no return type",
      "A function that is defined inside another function"
    ],
    "correct": 1,
    "category": "Functions",
    "type": "single"
  },
  {
    "question": "What is function overloading?",
    "options": [
      "Multiple functions with the same name but different parameters",
      "Multiple functions with different names but same parameters",
      "A function that calls another function multiple times",
      "Increasing the size of a function"
    ],
    "correct": 0,
    "category": "Functions",
    "type": "single"
  },
  {
    "question": "What is the return type of a constructor?",
    "options": [
      "void",
      "int",
      "The class type itself",
      "Constructors don't have a return type"
    ],
    "correct": 3,
    "category": "Functions",
    "type": "single"
  },
  {
    "question": "Which of the following is not a valid C++ keyword?",
    "options": [
      "virtual",
      "const",
      "friend",
      "main"
    ],
    "correct": 3,
    "category": "Keywords",
    "type": "single"
  },
  {
    "question": "What is the purpose of 'const' keyword in C++?",
    "options": [
      "To define constant variables",
      "To prevent modification of variables",
      "To optimize code",
      "Both A and B"
    ],
    "correct": 3,
    "category": "Keywords",
    "type": "single"
  },
  {
    "question": "What is the purpose of 'volatile' keyword in C++?",
    "options": [
      "To prevent compiler optimizations on a variable",
      "To make a variable constant",
      "To create a global variable",
      "To optimize memory usage"
    ],
    "correct": 0,
    "category": "Keywords",
    "type": "single"
  },
  {
    "question": "What is the purpose of 'mutable' keyword in C++?",
    "options": [
      "To allow modification of class members in const functions",
      "To create constant variables",
      "To prevent inheritance",
      "To optimize code"
    ],
    "correct": 0,
    "category": "Keywords",
    "type": "single"
  },
  {
    "question": "What is the purpose of 'static' keyword in C++?",
    "options": [
      "To create class-level variables",
      "To create functions that don't need object",
      "To limit visibility to file scope",
      "All of the above"
    ],
    "correct": 3,
    "category": "Keywords",
    "type": "single"
  },
  {
    "question": "What is the purpose of 'register' keyword in C++?",
    "options": [
      "To suggest storing variable in CPU register",
      "To optimize variable access",
      "It's largely ignored by modern compilers",
      "All of the above"
    ],
    "correct": 3,
    "category": "Keywords",
    "type": "single"
  },
  {
    "question": "What is the purpose of 'extern' keyword in C++?",
    "options": [
      "To declare variables defined in other files",
      "To create global variables",
      "To improve linking performance",
      "Both A and B"
    ],
    "correct": 3,
    "category": "Keywords",
    "type": "single"
  },
  {
    "question": "What is the difference between 'const' and 'constexpr'?",
    "options": [
      "constexpr evaluates at compile time",
      "constexpr can be used in more contexts",
      "constexpr was introduced in C++11",
      "All of the above"
    ],
    "correct": 3,
    "category": "Keywords",
    "type": "single"
  },
  {
    "question": "What is the difference between 'const' and 'volatile' qualifiers?",
    "options": [
      "const prevents modification, volatile prevents optimization",
      "const is for compile-time, volatile for runtime",
      "const applies to variables, volatile to memory locations",
      "All of the above"
    ],
    "correct": 3,
    "category": "Keywords",
    "type": "single"
  },
  {
    "question": "What is the difference between 'const' and 'constexpr' in terms of evaluation time?",
    "options": [
      "const can be runtime, constexpr must be compile-time",
      "constexpr enables compile-time evaluation",
      "constexpr has more restrictions",
      "All of the above"
    ],
    "correct": 3,
    "category": "Keywords",
    "type": "single"
  },
  {
    "question": "What causes memory leaks?",
    "options": [
      "Not freeing allocated memory",
      "Stack overflow",
      "Buffer overflow",
      "Type mismatch"
    ],
    "correct": 0,
    "category": "Memory",
    "type": "single"
  },
  {
    "question": "What is LIFO structure?",
    "options": [
      "Stack",
      "Queue",
      "Vector",
      "List"
    ],
    "correct": 0,
    "category": "Memory",
    "type": "single"
  },
  {
    "question": "What is used to free malloc'd memory?",
    "options": [
      "free()",
      "delete",
      "delete[]",
      "remove()"
    ],
    "correct": 0,
    "category": "Memory",
    "type": "single"
  },
  {
    "question": "What is allocated on the heap?",
    "options": [
      "Dynamic memory (new/malloc)",
      "Local variables",
      "Global variables",
      "Static variables"
    ],
    "correct": 0,
    "category": "Memory",
    "type": "single"
  },
  {
    "question": "What must you use to free 'new' memory?",
    "options": [
      "delete or delete[]",
      "free()",
      "remove()",
      "clear()"
    ],
    "correct": 0,
    "category": "Memory",
    "type": "single"
  },
  {
    "question": "What does 'new' operator do?",
    "options": [
      "Allocates memory on heap",
      "Allocates on stack",
      "Deletes memory",
      "Checks memory"
    ],
    "correct": 0,
    "category": "Memory",
    "type": "single"
  },
  {
    "question": "What does new[] allocate?",
    "options": [
      "Array on heap",
      "Single object",
      "Stack array",
      "Nothing"
    ],
    "correct": 0,
    "category": "Memory",
    "type": "single"
  },
  {
    "question": "What header is malloc in?",
    "options": [
      "<cstdlib> or <stdlib.h>",
      "<memory>",
      "<new>",
      "<malloc>"
    ],
    "correct": 0,
    "category": "Memory",
    "type": "single"
  },
  {
    "question": "What is the output of:\nint *p = new int[3];\np[0] = 10;\np[1] = 20;\np[2] = 30;\ncout << p[1];\ndelete[] p;",
    "options": [
      "10",
      "20",
      "30",
      "Compiler error"
    ],
    "correct": 1,
    "category": "Memory Management",
    "type": "single"
  },
  {
    "question": "What is the difference between 'new' and 'malloc' in C++?",
    "options": [
      "new calls constructor, malloc doesn't",
      "malloc is faster",
      "new returns void pointer",
      "malloc can allocate memory for objects"
    ],
    "correct": 0,
    "category": "Memory Management",
    "type": "single"
  },
  {
    "question": "What is the difference between shallow copy and deep copy?",
    "options": [
      "Shallow copy copies pointer values, deep copy creates new objects",
      "Deep copy is faster than shallow copy",
      "Shallow copy works only with primitive types",
      "Deep copy doesn't require destructor"
    ],
    "correct": 0,
    "category": "Memory Management",
    "type": "single"
  },
  {
    "question": "What is the difference between 'delete' and 'delete[]'?",
    "options": [
      "delete[",
      "Invalid option",
      "Invalid option",
      "Invalid option"
    ],
    "correct": 0,
    "category": "Memory Management",
    "type": "single"
  },
  {
    "question": "Which of the following is true about smart pointers?",
    "options": [
      "They automatically manage memory",
      "unique_ptr provides exclusive ownership",
      "shared_ptr uses reference counting",
      "All of the above"
    ],
    "correct": 3,
    "category": "Memory Management",
    "type": "single"
  },
  {
    "question": "What is the difference between 'new' and 'new[]'?",
    "options": [
      "new[",
      "Invalid option",
      "Invalid option",
      "Invalid option"
    ],
    "correct": 0,
    "category": "Memory Management",
    "type": "single"
  },
  {
    "question": "Which of the following is true about RAII?",
    "options": [
      "Resource Acquisition Is Initialization",
      "Resources are tied to object lifetime",
      "Prevents resource leaks",
      "All of the above"
    ],
    "correct": 3,
    "category": "Memory Management",
    "type": "single"
  },
  {
    "question": "What is the difference between 'new' and 'malloc' in terms of memory allocation?",
    "options": [
      "new calls constructor, malloc doesn't",
      "new is type-safe, malloc isn't",
      "new can be overloaded, malloc cannot",
      "All of the above"
    ],
    "correct": 3,
    "category": "Memory Management",
    "type": "single"
  },
  {
    "question": "Which of the following is true about RAII and smart pointers?",
    "options": [
      "Smart pointers implement RAII principle",
      "They automatically manage resource lifetime",
      "They prevent memory leaks",
      "All of the above"
    ],
    "correct": 3,
    "category": "Memory Management",
    "type": "single"
  },
  {
    "question": "Which keyword is used for automatic type deduction in C++11?",
    "options": [
      "type",
      "var",
      "auto",
      "decltype"
    ],
    "correct": 2,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is a lambda expression in C++11?",
    "options": [
      "A new way to define classes",
      "An anonymous function",
      "A template specialization",
      "A memory allocation technique"
    ],
    "correct": 1,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is the output of:\nauto f = [](int x) { return x*2; };\ncout << f(5);",
    "options": [
      "5",
      "10",
      "2",
      "Compiler error"
    ],
    "correct": 1,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "Which smart pointer is used for exclusive ownership?",
    "options": [
      "std::shared_ptr",
      "std::weak_ptr",
      "std::unique_ptr",
      "std::auto_ptr"
    ],
    "correct": 2,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What does 'constexpr' do?",
    "options": [
      "Defines a constant variable",
      "Indicates that a function or variable can be evaluated at compile time",
      "Specifies that a function is private",
      "Optimizes code for runtime performance"
    ],
    "correct": 1,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What does std::move do?",
    "options": [
      "Casts to rvalue reference",
      "Moves memory",
      "Copies data",
      "Deletes object"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "Which header contains smart pointers?",
    "options": [
      "<memory>",
      "<pointer>",
      "<smart>",
      "<auto>"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What type is nullptr?",
    "options": [
      "nullptr_t",
      "void*",
      "int",
      "NULL"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is lambda expression syntax?",
    "options": [
      "[capture](params){body}",
      "lambda(params)",
      "function<params>",
      "auto(params)"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What does 'auto' keyword do?",
    "options": [
      "Type inference",
      "Automatic storage",
      "Auto-initialization",
      "Automatic delete"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is range-based for syntax?",
    "options": [
      "for(auto& x : container)",
      "for(x in container)",
      "foreach(x:container)",
      "for x of container"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is the purpose of 'thread_local' storage specifier?",
    "options": [
      "To create variables with thread storage duration",
      "To ensure thread safety",
      "To create variables unique to each thread",
      "All of the above"
    ],
    "correct": 3,
    "category": "Multithreading",
    "type": "single"
  },
  {
    "question": "Which header is used for multithreading in C++11?",
    "options": [
      "<thread>",
      "<multi>",
      "<concurrent>",
      "<process>"
    ],
    "correct": 0,
    "category": "Multithreading",
    "type": "single"
  },
  {
    "question": "What is a 'mutex' used for?",
    "options": [
      "To speed up execution",
      "To prevent multiple threads from accessing shared data simultaneously",
      "To create a new thread",
      "To terminate a thread"
    ],
    "correct": 1,
    "category": "Multithreading",
    "type": "single"
  },
  {
    "question": "What is the purpose of 'namespace' in C++?",
    "options": [
      "To avoid name conflicts",
      "To organize code logically",
      "To create modular code",
      "All of the above"
    ],
    "correct": 3,
    "category": "Namespaces",
    "type": "single"
  },
  {
    "question": "What is the purpose of 'using' keyword in C++?",
    "options": [
      "To create type aliases",
      "To bring names into scope",
      "To simplify namespace usage",
      "All of the above"
    ],
    "correct": 3,
    "category": "Namespaces",
    "type": "single"
  },
  {
    "question": "Which of the following is not a valid C++ access specifier?",
    "options": [
      "public",
      "private",
      "protected",
      "internal"
    ],
    "correct": 3,
    "category": "OOP",
    "type": "single"
  },
  {
    "question": "What is the difference between struct and class in C++?",
    "options": [
      "Struct members are public by default, class members are private",
      "Struct cannot have member functions",
      "Class can inherit, struct cannot",
      "Struct is faster"
    ],
    "correct": 0,
    "category": "OOP",
    "type": "single"
  },
  {
    "question": "What is the purpose of 'explicit' keyword in constructors?",
    "options": [
      "To prevent implicit conversions",
      "To make constructor private",
      "To optimize constructor calls",
      "To create default constructors"
    ],
    "correct": 0,
    "category": "OOP",
    "type": "single"
  },
  {
    "question": "Which of the following is true about friend functions?",
    "options": [
      "They can access private members of a class",
      "They are not member functions",
      "They can be declared in any section of a class",
      "All of the above"
    ],
    "correct": 3,
    "category": "OOP",
    "type": "single"
  },
  {
    "question": "Which of the following is true about virtual destructors?",
    "options": [
      "They ensure proper cleanup when deleting derived class objects",
      "They should be defined when class has virtual functions",
      "They enable polymorphic destruction",
      "All of the above"
    ],
    "correct": 3,
    "category": "OOP",
    "type": "single"
  },
  {
    "question": "What is the difference between 'public', 'private', and 'protected' inheritance?",
    "options": [
      "Public inheritance maintains access levels, private makes all members private, protected makes all members protected",
      "Private inheritance is most restrictive, public is least restrictive",
      "Protected inheritance allows access to derived classes",
      "All of the above"
    ],
    "correct": 3,
    "category": "OOP",
    "type": "single"
  },
  {
    "question": "What is the difference between 'public', 'private', and 'protected' members?",
    "options": [
      "Public accessible anywhere, private only in class, protected in class and derived classes",
      "Private is most restrictive, public is least restrictive",
      "Protected allows access to derived classes",
      "All of the above"
    ],
    "correct": 3,
    "category": "OOP",
    "type": "single"
  },
  {
    "question": "Which of the following is true about multiple inheritance?",
    "options": [
      "A class can inherit from multiple base classes",
      "Can lead to diamond problem",
      "Requires virtual inheritance to resolve ambiguity",
      "All of the above"
    ],
    "correct": 3,
    "category": "OOP",
    "type": "single"
  },
  {
    "question": "Which of the following is true about abstract classes?",
    "options": [
      "They cannot be instantiated",
      "They must have at least one pure virtual function",
      "They can have regular member functions",
      "All of the above"
    ],
    "correct": 3,
    "category": "OOP",
    "type": "single"
  },
  {
    "question": "Which of the following is true about virtual inheritance?",
    "options": [
      "It solves the diamond problem in multiple inheritance",
      "It ensures only one instance of base class",
      "It uses virtual base class concept",
      "All of the above"
    ],
    "correct": 3,
    "category": "OOP",
    "type": "single"
  },
  {
    "question": "What is the difference between 'const' member functions and non-const member functions?",
    "options": [
      "Const functions don't modify object state",
      "Const functions can be called on const objects",
      "Const functions have different this pointer type",
      "All of the above"
    ],
    "correct": 3,
    "category": "OOP",
    "type": "single"
  },
  {
    "question": "What is the difference between 'public', 'private', and 'protected' inheritance in terms of access control?",
    "options": [
      "Public inheritance preserves access levels",
      "Private inheritance makes all members private",
      "Protected inheritance makes all members protected",
      "All of the above"
    ],
    "correct": 3,
    "category": "OOP",
    "type": "single"
  },
  {
    "question": "Which principle of OOP is used to hide internal details and show only necessary features?",
    "options": [
      "Inheritance",
      "Polymorphism",
      "Encapsulation",
      "Abstraction"
    ],
    "correct": 3,
    "category": "OOP",
    "type": "single"
  },
  {
    "question": "What is a virtual function in C++?",
    "options": [
      "A function that has no body",
      "A function that can be overridden in a derived class",
      "A function that is private",
      "A function that is static"
    ],
    "correct": 1,
    "category": "OOP",
    "type": "single"
  },
  {
    "question": "What is multiple inheritance?",
    "options": [
      "One class inheriting from multiple base classes",
      "Multiple classes inheriting from one base class",
      "One class inheriting from another class which inherits from another",
      "Multiple objects of the same class"
    ],
    "correct": 0,
    "category": "OOP",
    "type": "single"
  },
  {
    "question": "What is the purpose of the 'this' pointer?",
    "options": [
      "To refer to the current object",
      "To refer to the base class",
      "To refer to the next object in memory",
      "To refer to a static member"
    ],
    "correct": 0,
    "category": "OOP",
    "type": "single"
  },
  {
    "question": "What is destructor syntax?",
    "options": [
      "~ClassName()",
      "delete ClassName",
      "ClassName~()",
      "destroy()"
    ],
    "correct": 0,
    "category": "OOP",
    "type": "single"
  },
  {
    "question": "What is default class member access?",
    "options": [
      "private",
      "public",
      "protected",
      "internal"
    ],
    "correct": 0,
    "category": "OOP",
    "type": "single"
  },
  {
    "question": "What makes a class abstract?",
    "options": [
      "Pure virtual function",
      "Virtual function",
      "Private constructor",
      "Static members"
    ],
    "correct": 0,
    "category": "OOP",
    "type": "single"
  },
  {
    "question": "When is constructor called?",
    "options": [
      "Object creation",
      "Object deletion",
      "Method call",
      "Variable access"
    ],
    "correct": 0,
    "category": "OOP",
    "type": "single"
  },
  {
    "question": "What enables runtime polymorphism?",
    "options": [
      "Virtual functions",
      "Templates",
      "Overloading",
      "Inheritance only"
    ],
    "correct": 0,
    "category": "OOP",
    "type": "single"
  },
  {
    "question": "What keyword enables inheritance?",
    "options": [
      ": (colon)",
      "extends",
      "inherits",
      "derives"
    ],
    "correct": 0,
    "category": "OOP",
    "type": "single"
  },
  {
    "question": "How to create object on heap?",
    "options": [
      "new ClassName()",
      "ClassName()",
      "malloc()",
      "create()"
    ],
    "correct": 0,
    "category": "OOP",
    "type": "single"
  },
  {
    "question": "What is difference between class and struct?",
    "options": [
      "Default access (private vs public)",
      "No difference",
      "Struct can't have methods",
      "Class is faster"
    ],
    "correct": 0,
    "category": "OOP",
    "type": "single"
  },
  {
    "question": "What is the output of:\nclass Point {\npublic:\n  int x;\n  Point(int v): x(v) {}\n  Point operator+(Point p) { return Point(x+p.x); }\n};\nPoint p1(5), p2(10);\nPoint p3 = p1 + p2;\ncout << p3.x;",
    "options": [
      "5",
      "10",
      "15",
      "Compiler error"
    ],
    "correct": 2,
    "category": "Operator Overloading",
    "type": "single"
  },
  {
    "question": "Which operator cannot be overloaded in C++?",
    "options": [
      ". (dot)",
      "->",
      "new",
      "delete"
    ],
    "correct": 0,
    "category": "Operator Overloading",
    "type": "single"
  },
  {
    "question": "What is the output of the following code?\nint x = 5;\ncout << x++ << \" \" << ++x;",
    "options": [
      "5 6",
      "6 6",
      "5 7",
      "6 7"
    ],
    "correct": 2,
    "category": "Operators",
    "type": "single"
  },
  {
    "question": "What is the output of: cout << (10 == 10 == 10);",
    "options": [
      "1",
      "0",
      "true",
      "false"
    ],
    "correct": 0,
    "category": "Operators",
    "type": "single"
  },
  {
    "question": "What is the output of:\nint x = 5, y = 0;\ncout << (x || y) << (x && y);",
    "options": [
      "10",
      "01",
      "11",
      "00"
    ],
    "correct": 0,
    "category": "Operators",
    "type": "single"
  },
  {
    "question": "What is the output of: cout << (true && false || true);",
    "options": [
      "0",
      "1",
      "true",
      "false"
    ],
    "correct": 1,
    "category": "Operators",
    "type": "single"
  },
  {
    "question": "What is the output of:\nint a = 5, b = 3;\ncout << (a & b);",
    "options": [
      "1",
      "3",
      "5",
      "7"
    ],
    "correct": 0,
    "category": "Operators",
    "type": "single"
  },
  {
    "question": "What is the output of: int a = 3, b = 2; cout << (a ^ b);",
    "options": [
      "1",
      "5",
      "0",
      "Compiler error"
    ],
    "correct": 0,
    "category": "Operators",
    "type": "single"
  },
  {
    "question": "What is the output of:\nint x = 17;\ncout << (x % 5);",
    "options": [
      "2",
      "3",
      "4",
      "5"
    ],
    "correct": 0,
    "category": "Operators",
    "type": "single"
  },
  {
    "question": "What is the output of: int x = 10; cout << (x << 1);",
    "options": [
      "20",
      "5",
      "1",
      "Compiler error"
    ],
    "correct": 0,
    "category": "Operators",
    "type": "single"
  },
  {
    "question": "What is the output of:\nint x = 5, y = 10, z = 15;\nint max = (x>y) ? ((x>z)?x:z) : ((y>z)?y:z);\ncout << max;",
    "options": [
      "5",
      "10",
      "15",
      "Undefined"
    ],
    "correct": 2,
    "category": "Operators",
    "type": "single"
  },
  {
    "question": "What is the output of: int x = 5; cout << (x = 10) + (x = 20);",
    "options": [
      "20",
      "30",
      "15",
      "Undefined behavior"
    ],
    "correct": 3,
    "category": "Operators",
    "type": "single"
  },
  {
    "question": "What is the output of:\nint x = 0;\nif(x && (x=5))\n  cout << x;\nelse\n  cout << x;",
    "options": [
      "0",
      "5",
      "Nothing",
      "Compiler error"
    ],
    "correct": 0,
    "category": "Operators",
    "type": "single"
  },
  {
    "question": "What is the output of: int x = 3; cout << (x++ + ++x);",
    "options": [
      "7",
      "8",
      "Undefined behavior",
      "Compiler error"
    ],
    "correct": 2,
    "category": "Operators",
    "type": "single"
  },
  {
    "question": "What is the output of: int x = 10; int y = x << 2; cout << y;",
    "options": [
      "20",
      "40",
      "5",
      "Compiler error"
    ],
    "correct": 1,
    "category": "Operators",
    "type": "single"
  },
  {
    "question": "What is the output of: int x = 5; int y = x-- + --x; cout << x << \" \" << y;",
    "options": [
      "3 7",
      "4 8",
      "3 8",
      "4 7"
    ],
    "correct": 0,
    "category": "Operators",
    "type": "single"
  },
  {
    "question": "What is the output of: int x = 10; cout << (x > 5 ? \"A\" : \"B\");",
    "options": [
      "A",
      "B",
      "1",
      "0"
    ],
    "correct": 0,
    "category": "Operators",
    "type": "single"
  },
  {
    "question": "What is the output of: int x = 5; int y = 3; cout << (x / y * y + x % y);",
    "options": [
      "5",
      "6",
      "8",
      "10"
    ],
    "correct": 0,
    "category": "Operators",
    "type": "single"
  },
  {
    "question": "What is the output of: int x = 10; cout << (x |= 3);",
    "options": [
      "10",
      "11",
      "15",
      "Compiler error"
    ],
    "correct": 1,
    "category": "Operators",
    "type": "single"
  },
  {
    "question": "What is the output of: int x = 5; cout << (x ^= 3);",
    "options": [
      "5",
      "6",
      "8",
      "Compiler error"
    ],
    "correct": 1,
    "category": "Operators",
    "type": "single"
  },
  {
    "question": "What is the output of:\nint x = 16;\ncout << (x >> 2);",
    "options": [
      "4",
      "8",
      "32",
      "64"
    ],
    "correct": 0,
    "category": "Operators",
    "type": "single"
  },
  {
    "question": "What is the output of: int x = 10; cout << (x >> 1);",
    "options": [
      "5",
      "20",
      "1",
      "Compiler error"
    ],
    "correct": 0,
    "category": "Operators",
    "type": "single"
  },
  {
    "question": "Which of the following is true about copy assignment operator?",
    "options": [
      "It assigns values from one object to another",
      "It should handle self-assignment",
      "It returns reference to the object",
      "All of the above"
    ],
    "correct": 3,
    "category": "Operators",
    "type": "single"
  },
  {
    "question": "What is the output of:\nint a = 12, b = 10;\ncout << (a | b);",
    "options": [
      "14",
      "10",
      "12",
      "2"
    ],
    "correct": 0,
    "category": "Operators",
    "type": "single"
  },
  {
    "question": "What is the output of: int x = 5; int y = 2; cout << (x / y);",
    "options": [
      "2.5",
      "2",
      "3",
      "Compiler error"
    ],
    "correct": 1,
    "category": "Operators",
    "type": "single"
  },
  {
    "question": "What is the output of: int x = 10; int y = 5; cout << (x %= y);",
    "options": [
      "10",
      "5",
      "0",
      "Compiler error"
    ],
    "correct": 2,
    "category": "Operators",
    "type": "single"
  },
  {
    "question": "What is the difference between 'prefix' and 'postfix' increment?",
    "options": [
      "Prefix increments then returns, postfix returns then increments",
      "Prefix is faster than postfix",
      "Prefix can be used as lvalue, postfix cannot",
      "All of the above"
    ],
    "correct": 3,
    "category": "Operators",
    "type": "single"
  },
  {
    "question": "What is the output of: int x = 5; int y = 3; cout << (x *= y);",
    "options": [
      "5",
      "8",
      "15",
      "Compiler error"
    ],
    "correct": 2,
    "category": "Operators",
    "type": "single"
  },
  {
    "question": "What is the output of: int x = 10; int y = 3; cout << (x -= y);",
    "options": [
      "10",
      "7",
      "3",
      "Compiler error"
    ],
    "correct": 1,
    "category": "Operators",
    "type": "single"
  },
  {
    "question": "What is the output of: int x = 5; int y = 2; cout << (x += y);",
    "options": [
      "5",
      "7",
      "10",
      "Compiler error"
    ],
    "correct": 1,
    "category": "Operators",
    "type": "single"
  },
  {
    "question": "What is the output of: int x = 10; int y = 4; cout << (x %= y);",
    "options": [
      "10",
      "4",
      "2",
      "Compiler error"
    ],
    "correct": 2,
    "category": "Operators",
    "type": "single"
  },
  {
    "question": "What is the output of: int x = 5; int y = 3; cout << (x /= y);",
    "options": [
      "5",
      "1",
      "3",
      "Compiler error"
    ],
    "correct": 1,
    "category": "Operators",
    "type": "single"
  },
  {
    "question": "What is the output of: int x = 10; int y = 6; cout << (x %= y);",
    "options": [
      "10",
      "6",
      "4",
      "Compiler error"
    ],
    "correct": 2,
    "category": "Operators",
    "type": "single"
  },
  {
    "question": "What is the output of: int x = 5; int y = 4; cout << (x |= y);",
    "options": [
      "5",
      "9",
      "1",
      "Compiler error"
    ],
    "correct": 1,
    "category": "Operators",
    "type": "single"
  },
  {
    "question": "What is the output of: int x = 10; int y = 7; cout << (x %= y);",
    "options": [
      "10",
      "7",
      "3",
      "Compiler error"
    ],
    "correct": 2,
    "category": "Operators",
    "type": "single"
  },
  {
    "question": "What is the output of: int x = 5; int y = 5; cout << (x ^= y);",
    "options": [
      "5",
      "0",
      "10",
      "Compiler error"
    ],
    "correct": 1,
    "category": "Operators",
    "type": "single"
  },
  {
    "question": "What is the output of: int x = 10; int y = 8; cout << (x %= y);",
    "options": [
      "10",
      "8",
      "2",
      "Compiler error"
    ],
    "correct": 2,
    "category": "Operators",
    "type": "single"
  },
  {
    "question": "What is the output of: int x = 10; int y = 9; cout << (x %= y);",
    "options": [
      "10",
      "9",
      "1",
      "Compiler error"
    ],
    "correct": 2,
    "category": "Operators",
    "type": "single"
  },
  {
    "question": "What is the output of: int x = 10; int y = 5; cout << (x /= y);",
    "options": [
      "10",
      "2",
      "5",
      "Compiler error"
    ],
    "correct": 1,
    "category": "Operators",
    "type": "single"
  },
  {
    "question": "What is the output of: int x = 10; int y = 3; cout << (x %= y);",
    "options": [
      "10",
      "3",
      "1",
      "Compiler error"
    ],
    "correct": 2,
    "category": "Operators",
    "type": "single"
  },
  {
    "question": "What is the output of sizeof(nullptr)?",
    "options": [
      "0",
      "1",
      "4 or 8 (depends on system)",
      "Compiler error"
    ],
    "correct": 2,
    "category": "Pointers",
    "type": "single"
  },
  {
    "question": "What is the output of: int arr[] = {1,2,3,4,5}; cout << *(arr + 2);",
    "options": [
      "1",
      "2",
      "3",
      "4"
    ],
    "correct": 2,
    "category": "Pointers",
    "type": "single"
  },
  {
    "question": "What is the output of:\nint x = 5;\nint *p = &x;\ncout << *p + 1;",
    "options": [
      "5",
      "6",
      "Address",
      "Compiler error"
    ],
    "correct": 1,
    "category": "Pointers",
    "type": "single"
  },
  {
    "question": "What is the output of: cout << (NULL == 0);",
    "options": [
      "0",
      "1",
      "true",
      "false"
    ],
    "correct": 1,
    "category": "Pointers",
    "type": "single"
  },
  {
    "question": "What is the output of: int arr[] = {1,2,3}; int *p = arr; cout << *(p + 2);",
    "options": [
      "1",
      "2",
      "3",
      "Compiler error"
    ],
    "correct": 2,
    "category": "Pointers",
    "type": "single"
  },
  {
    "question": "Which of the following is true about function pointers?",
    "options": [
      "They store memory addresses of functions",
      "They can be used for callbacks",
      "They enable polymorphic behavior",
      "All of the above"
    ],
    "correct": 3,
    "category": "Pointers",
    "type": "single"
  },
  {
    "question": "What is the output of:\nint add(int a, int b) { return a+b; }\nint (*fptr)(int, int) = add;\ncout << fptr(3, 7);",
    "options": [
      "3",
      "7",
      "10",
      "Compiler error"
    ],
    "correct": 2,
    "category": "Pointers",
    "type": "single"
  },
  {
    "question": "How do you declare a pointer to an integer?",
    "options": [
      "int x;",
      "int &x;",
      "int *x;",
      "int ^x;"
    ],
    "correct": 2,
    "category": "Pointers",
    "type": "single"
  },
  {
    "question": "What is a dangling pointer?",
    "options": [
      "A pointer that points to a valid memory location",
      "A pointer that points to a memory location that has been deleted",
      "A pointer that has not been initialized",
      "A pointer that points to the null address"
    ],
    "correct": 1,
    "category": "Pointers",
    "type": "single"
  },
  {
    "question": "Which operator is used to get the address of a variable?",
    "options": [
      "*",
      "&",
      "->",
      "."
    ],
    "correct": 1,
    "category": "Pointers",
    "type": "single"
  },
  {
    "question": "Can void* be dereferenced directly?",
    "options": [
      "No, must cast first",
      "Yes",
      "Only in C",
      "Only in C++"
    ],
    "correct": 0,
    "category": "Pointers",
    "type": "single"
  },
  {
    "question": "Can references be null?",
    "options": [
      "No, must refer to object",
      "Yes",
      "Only if const",
      "Only if static"
    ],
    "correct": 0,
    "category": "Pointers",
    "type": "single"
  },
  {
    "question": "What does * operator do to pointer?",
    "options": [
      "Dereferences (gets value)",
      "Gets address",
      "Creates pointer",
      "Deletes pointer"
    ],
    "correct": 0,
    "category": "Pointers",
    "type": "single"
  },
  {
    "question": "What does ptr + 1 do?",
    "options": [
      "Advances to next element",
      "Adds 1 byte",
      "Adds 1 bit",
      "Error"
    ],
    "correct": 0,
    "category": "Pointers",
    "type": "single"
  },
  {
    "question": "What is pointer aliasing?",
    "options": [
      "Multiple pointers to same location",
      "Renaming pointer",
      "Copying pointer",
      "Deleting pointer"
    ],
    "correct": 0,
    "category": "Pointers",
    "type": "single"
  },
  {
    "question": "What is the output of:\nclass Base {\npublic:\n  virtual void show() { cout << \"Base\"; }\n};\nclass Der : public Base {\npublic:\n  void show() { cout << \"Der\"; }\n};\nBase *b = new Der();\nb->show();",
    "options": [
      "Base",
      "Der",
      "Compiler error",
      "Undefined"
    ],
    "correct": 1,
    "category": "Polymorphism",
    "type": "single"
  },
  {
    "question": "Which of the following is true about virtual functions?",
    "options": [
      "They must be defined in base class",
      "They can be static",
      "They enable runtime polymorphism",
      "They are faster than regular functions"
    ],
    "correct": 2,
    "category": "Polymorphism",
    "type": "single"
  },
  {
    "question": "Which of the following is true about pure virtual functions?",
    "options": [
      "They must be defined in derived class",
      "They can have implementation in base class",
      "They make the class abstract",
      "All of the above"
    ],
    "correct": 3,
    "category": "Polymorphism",
    "type": "single"
  },
  {
    "question": "What is the difference between 'static' and 'dynamic' binding?",
    "options": [
      "Static binding at compile time, dynamic at runtime",
      "Static uses function pointers, dynamic uses vtables",
      "Static is faster than dynamic",
      "All of the above"
    ],
    "correct": 3,
    "category": "Polymorphism",
    "type": "single"
  },
  {
    "question": "What is the difference between 'static' and 'dynamic' polymorphism?",
    "options": [
      "Static resolved at compile time, dynamic at runtime",
      "Static uses templates, dynamic uses virtual functions",
      "Static is faster than dynamic",
      "All of the above"
    ],
    "correct": 3,
    "category": "Polymorphism",
    "type": "single"
  },
  {
    "question": "What is the output of:\n#define SQUARE(x) x*x\ncout << SQUARE(2+3);",
    "options": [
      "25",
      "11",
      "10",
      "Compiler error"
    ],
    "correct": 1,
    "category": "Preprocessor",
    "type": "single"
  },
  {
    "question": "Which of the following is not a valid C++ preprocessor directive?",
    "options": [
      "#include",
      "#define",
      "#import",
      "#ifdef"
    ],
    "correct": 2,
    "category": "Preprocessor",
    "type": "single"
  },
  {
    "question": "What is the output of:\nint x = 5;\nint &y = x;\ny = 10;\ncout << x;",
    "options": [
      "5",
      "10",
      "Compiler error",
      "Garbage value"
    ],
    "correct": 1,
    "category": "References",
    "type": "single"
  },
  {
    "question": "Which container in STL provides O(1) time complexity for insertion and deletion?",
    "options": [
      "vector",
      "list",
      "map",
      "set"
    ],
    "correct": 1,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "What is the output of:\nvector<int> v = {1,2,3};\nv.push_back(4);\ncout << v.size();",
    "options": [
      "3",
      "4",
      "5",
      "Compiler error"
    ],
    "correct": 1,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "Which STL algorithm sorts elements in ascending order?",
    "options": [
      "sort()",
      "qsort()",
      "order()",
      "arrange()"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "Which STL container provides constant time access to elements?",
    "options": [
      "std::list",
      "std::vector",
      "std::map",
      "std::set"
    ],
    "correct": 1,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "Which STL algorithm finds the first occurrence of a value?",
    "options": [
      "find()",
      "search()",
      "locate()",
      "discover()"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "Which STL container implements a double-ended queue?",
    "options": [
      "std::queue",
      "std::deque",
      "std::stack",
      "std::list"
    ],
    "correct": 1,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "Which STL container provides O(log n) insertion and deletion?",
    "options": [
      "std::vector",
      "std::list",
      "std::set",
      "std::unordered_set"
    ],
    "correct": 2,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "Which STL algorithm reverses a sequence?",
    "options": [
      "reverse()",
      "flip()",
      "invert()",
      "turn()"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "Which STL container implements a priority queue?",
    "options": [
      "std::queue",
      "std::priority_queue",
      "std::stack",
      "std::heap"
    ],
    "correct": 1,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "Which STL algorithm removes consecutive duplicates?",
    "options": [
      "remove()",
      "unique()",
      "erase()",
      "delete()"
    ],
    "correct": 1,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "Which STL container provides constant time insertion at beginning?",
    "options": [
      "std::vector",
      "std::list",
      "std::deque",
      "std::set"
    ],
    "correct": 2,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "Which STL algorithm sorts in descending order?",
    "options": [
      "sort() with greater comparator",
      "rsort()",
      "descend()",
      "order_desc()"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "Which STL container provides O(1) access to first and last elements?",
    "options": [
      "std::vector",
      "std::list",
      "std::deque",
      "std::set"
    ],
    "correct": 2,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "Which STL algorithm counts occurrences of a value?",
    "options": [
      "count()",
      "occurrences()",
      "frequency()",
      "tally()"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "Which STL container provides O(1) insertion and deletion at both ends?",
    "options": [
      "std::vector",
      "std::list",
      "std::deque",
      "std::set"
    ],
    "correct": 2,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "Which STL algorithm finds the maximum element?",
    "options": [
      "max()",
      "max_element()",
      "find_max()",
      "greatest()"
    ],
    "correct": 1,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "Which STL container provides O(log n) search time?",
    "options": [
      "std::vector",
      "std::list",
      "std::map",
      "std::unordered_map"
    ],
    "correct": 2,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "Which STL container provides O(1) average insertion and deletion?",
    "options": [
      "std::vector",
      "std::list",
      "std::unordered_set",
      "std::set"
    ],
    "correct": 2,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "Which STL container provides O(1) access to any element?",
    "options": [
      "std::vector",
      "std::list",
      "std::map",
      "std::set"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "Which STL algorithm removes elements from a container?",
    "options": [
      "remove()",
      "erase()",
      "delete()",
      "clear()"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "Which STL container provides O(n) search time?",
    "options": [
      "std::vector",
      "std::list",
      "std::map",
      "std::set"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "Which STL container provides O(1) insertion at end?",
    "options": [
      "std::vector",
      "std::list",
      "std::deque",
      "std::set"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "Which STL container provides O(log n) insertion?",
    "options": [
      "std::vector",
      "std::list",
      "std::set",
      "std::unordered_set"
    ],
    "correct": 2,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "Which STL container provides O(1) deletion at end?",
    "options": [
      "std::vector",
      "std::list",
      "std::deque",
      "std::set"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "Which STL container provides O(n) insertion at beginning?",
    "options": [
      "std::vector",
      "std::list",
      "std::deque",
      "std::set"
    ],
    "correct": 1,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "Which STL container provides O(1) access to last element?",
    "options": [
      "std::vector",
      "std::list",
      "std::deque",
      "std::set"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "Which STL container provides O(log n) deletion?",
    "options": [
      "std::vector",
      "std::list",
      "std::set",
      "std::unordered_set"
    ],
    "correct": 2,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "Which STL container provides O(1) insertion at beginning and end?",
    "options": [
      "std::vector",
      "std::list",
      "std::deque",
      "std::set"
    ],
    "correct": 2,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "Which STL container provides O(n) search time for unordered elements?",
    "options": [
      "std::vector",
      "std::list",
      "std::unordered_set",
      "std::set"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "Which STL container provides O(1) average insertion time?",
    "options": [
      "std::vector",
      "std::list",
      "std::unordered_set",
      "std::set"
    ],
    "correct": 2,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "Which STL container provides O(n) insertion time?",
    "options": [
      "std::vector",
      "std::list",
      "std::set",
      "std::unordered_set"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "Which STL container provides O(1) access to first element?",
    "options": [
      "std::vector",
      "std::list",
      "std::deque",
      "std::set"
    ],
    "correct": 1,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "Which STL container provides O(log n) average insertion time?",
    "options": [
      "std::vector",
      "std::list",
      "std::set",
      "std::unordered_set"
    ],
    "correct": 2,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "Which STL container provides O(1) average deletion time?",
    "options": [
      "std::vector",
      "std::list",
      "std::unordered_set",
      "std::set"
    ],
    "correct": 2,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "Which STL container provides O(n) deletion time?",
    "options": [
      "std::vector",
      "std::list",
      "std::set",
      "std::unordered_set"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "Which STL container provides O(log n) average deletion time?",
    "options": [
      "std::vector",
      "std::list",
      "std::set",
      "std::unordered_set"
    ],
    "correct": 2,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "Which STL container provides O(1) average access time?",
    "options": [
      "std::vector",
      "std::list",
      "std::unordered_map",
      "std::map"
    ],
    "correct": 2,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "Which STL container provides O(log n) average access time?",
    "options": [
      "std::vector",
      "std::list",
      "std::set",
      "std::unordered_set"
    ],
    "correct": 2,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "Which STL container provides O(1) average insertion at end?",
    "options": [
      "std::vector",
      "std::list",
      "std::deque",
      "std::set"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "Which STL container provides O(log n) average insertion at beginning?",
    "options": [
      "std::vector",
      "std::list",
      "std::set",
      "std::unordered_set"
    ],
    "correct": 2,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "Which STL container provides O(1) average deletion at beginning?",
    "options": [
      "std::vector",
      "std::list",
      "std::deque",
      "std::set"
    ],
    "correct": 1,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "Which STL container provides O(log n) average deletion at end?",
    "options": [
      "std::vector",
      "std::list",
      "std::set",
      "std::unordered_set"
    ],
    "correct": 2,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "Which STL container provides O(1) average access to any element?",
    "options": [
      "std::vector",
      "std::list",
      "std::unordered_map",
      "std::map"
    ],
    "correct": 2,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "Which STL container provides O(log n) average access to any element?",
    "options": [
      "std::vector",
      "std::list",
      "std::map",
      "std::unordered_map"
    ],
    "correct": 2,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "Which STL container provides O(1) average insertion at any position?",
    "options": [
      "std::vector",
      "std::list",
      "std::deque",
      "std::set"
    ],
    "correct": 1,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "Which STL container provides O(1) average deletion at any position?",
    "options": [
      "std::vector",
      "std::list",
      "std::deque",
      "std::set"
    ],
    "correct": 1,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "Which STL container provides O(log n) average insertion at any position?",
    "options": [
      "std::vector",
      "std::list",
      "std::set",
      "std::unordered_set"
    ],
    "correct": 2,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "Which STL container provides O(1) average access to first and last elements?",
    "options": [
      "std::vector",
      "std::list",
      "std::deque",
      "std::set"
    ],
    "correct": 2,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "Which STL container provides O(log n) average deletion at any position?",
    "options": [
      "std::vector",
      "std::list",
      "std::set",
      "std::unordered_set"
    ],
    "correct": 2,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "Which STL container provides O(1) average insertion and deletion at both ends?",
    "options": [
      "std::vector",
      "std::list",
      "std::deque",
      "std::set"
    ],
    "correct": 2,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "Which STL container provides O(log n) average access to first and last elements?",
    "options": [
      "std::vector",
      "std::list",
      "std::map",
      "std::set"
    ],
    "correct": 2,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "Which STL container provides O(1) average access to any element with constant time complexity?",
    "options": [
      "std::vector",
      "std::list",
      "std::unordered_map",
      "std::map"
    ],
    "correct": 2,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "Which STL container provides O(1) average insertion and deletion at any position with constant time complexity?",
    "options": [
      "std::vector",
      "std::list",
      "std::deque",
      "std::set"
    ],
    "correct": 1,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "Which STL container provides O(log n) average insertion and deletion time?",
    "options": [
      "std::vector",
      "std::list",
      "std::set",
      "std::unordered_set"
    ],
    "correct": 2,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "Which STL container provides O(log n) average insertion time with logarithmic complexity?",
    "options": [
      "std::vector",
      "std::list",
      "std::set",
      "std::unordered_set"
    ],
    "correct": 2,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "What is the purpose of 'std::make_pair' in C++?",
    "options": [
      "To create pair objects",
      "To enable efficient pair creation",
      "To work with STL algorithms",
      "All of the above"
    ],
    "correct": 3,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "Which STL container provides O(1) average deletion time with constant time complexity?",
    "options": [
      "std::vector",
      "std::list",
      "std::unordered_set",
      "std::set"
    ],
    "correct": 2,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "Which STL container provides O(log n) average access time with logarithmic complexity?",
    "options": [
      "std::vector",
      "std::list",
      "std::map",
      "std::unordered_map"
    ],
    "correct": 2,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "Which STL container provides O(1) average insertion time with constant time complexity?",
    "options": [
      "std::vector",
      "std::list",
      "std::unordered_set",
      "std::set"
    ],
    "correct": 2,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "Which STL container provides O(log n) average deletion time with logarithmic complexity?",
    "options": [
      "std::vector",
      "std::list",
      "std::set",
      "std::unordered_set"
    ],
    "correct": 2,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "Which STL container is implemented as a doubly linked list?",
    "options": [
      "vector",
      "deque",
      "list",
      "forward_list"
    ],
    "correct": 2,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "What is the complexity of accessing an element in a 'std::vector' by index?",
    "options": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n log n)"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "Which STL container stores key-value pairs in sorted order?",
    "options": [
      "std::unordered_map",
      "std::map",
      "std::vector",
      "std::set"
    ],
    "correct": 1,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "Does std::set allow duplicates?",
    "options": [
      "No, unique elements only",
      "Yes",
      "Only if sorted",
      "Depends on type"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "What is time complexity of vector push_back?",
    "options": [
      "O(1) amortized",
      "O(n)",
      "O(log n)",
      "O(n^2)"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "What data structure is std::list?",
    "options": [
      "Doubly linked list",
      "Array",
      "Hash table",
      "Binary tree"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "What is FIFO structure?",
    "options": [
      "Queue",
      "Stack",
      "Vector",
      "List"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "Which header contains STL algorithms?",
    "options": [
      "<algorithm>",
      "<algo>",
      "<stl>",
      "<functions>"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "What does deque stand for?",
    "options": [
      "Double-ended queue",
      "Decimal queue",
      "Delete queue",
      "Data queue"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "What is time complexity of map lookup?",
    "options": [
      "O(log n)",
      "O(1)",
      "O(n)",
      "O(n log n)"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "What is the difference between deque and vector?",
    "options": [
      "Deque allows O(1) insertion at both ends",
      "Deque is faster",
      "Vector is newer",
      "No difference"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "What does queue.front() return?",
    "options": [
      "First element in queue",
      "Last element",
      "Queue size",
      "Queue capacity"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "Which header file is required for string operations?",
    "options": [
      "<string>",
      "<cstring>",
      "<string.h>",
      "Both A and B"
    ],
    "correct": 3,
    "category": "Standard Library",
    "type": "single"
  },
  {
    "question": "Which header file is required for mathematical functions?",
    "options": [
      "<math>",
      "<cmath>",
      "<math.h>",
      "Both B and C"
    ],
    "correct": 3,
    "category": "Standard Library",
    "type": "single"
  },
  {
    "question": "Which header file is required for input/output operations?",
    "options": [
      "<io>",
      "<iostream>",
      "<stdio>",
      "<cin>"
    ],
    "correct": 1,
    "category": "Standard Library",
    "type": "single"
  },
  {
    "question": "Which of the following is not a valid C++ storage class?",
    "options": [
      "auto",
      "register",
      "static",
      "volatile"
    ],
    "correct": 3,
    "category": "Storage Classes",
    "type": "single"
  },
  {
    "question": "Which of the following is true about function templates?",
    "options": [
      "They enable generic programming",
      "They are instantiated at compile time",
      "They can work with different data types",
      "All of the above"
    ],
    "correct": 3,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "What is the purpose of 'typename' keyword in C++?",
    "options": [
      "To specify dependent types in templates",
      "To create type aliases",
      "To define new data types",
      "To optimize template code"
    ],
    "correct": 0,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "Which of the following is true about function templates vs class templates?",
    "options": [
      "Function templates can have default arguments",
      "Class templates can have default arguments",
      "Function templates are instantiated implicitly",
      "Both B and C"
    ],
    "correct": 3,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "What is the difference between 'class' and 'typename' in templates?",
    "options": [
      "They are interchangeable in most contexts",
      "class can only be used for class types",
      "typename is more modern",
      "Both A and C"
    ],
    "correct": 3,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "What is the difference between 'class templates' and 'function templates'?",
    "options": [
      "Class templates can have default arguments",
      "Function templates are instantiated implicitly",
      "Class templates can be partially specialized",
      "All of the above"
    ],
    "correct": 3,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "Which of the following is true about template specialization?",
    "options": [
      "It provides custom implementations for specific types",
      "It can be partial or full",
      "It enables optimization for specific types",
      "All of the above"
    ],
    "correct": 3,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "Which of the following is true about SFINAE?",
    "options": [
      "Substitution Failure Is Not An Error",
      "It enables template metaprogramming",
      "It allows function overload resolution based on template arguments",
      "All of the above"
    ],
    "correct": 3,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "Which of the following is true about template metaprogramming?",
    "options": [
      "It performs computations at compile time",
      "It uses template instantiation",
      "It enables type-level computations",
      "All of the above"
    ],
    "correct": 3,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "Which of the following is true about template argument deduction?",
    "options": [
      "Compiler deduces template arguments from function arguments",
      "It works with function templates",
      "It can be guided with explicit template arguments",
      "All of the above"
    ],
    "correct": 3,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "Which of the following is true about template instantiation?",
    "options": [
      "It creates concrete types from template definitions",
      "It happens at compile time",
      "It can be explicit or implicit",
      "All of the above"
    ],
    "correct": 3,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "Which of the following is true about template specialization vs overloading?",
    "options": [
      "Specialization provides custom implementation for specific types",
      "Overloading creates different function templates",
      "Specialization is more specific than overloading",
      "All of the above"
    ],
    "correct": 3,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "Which of the following is true about template default arguments?",
    "options": [
      "They provide default values for template parameters",
      "They enable more flexible template usage",
      "They were introduced in C++11",
      "All of the above"
    ],
    "correct": 3,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "Which of the following is true about template aliasing?",
    "options": [
      "It creates aliases for template types",
      "It uses 'using' keyword",
      "It simplifies complex template types",
      "All of the above"
    ],
    "correct": 3,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "Which of the following is true about template metaprogramming techniques?",
    "options": [
      "It uses recursive template instantiation",
      "It enables compile-time computations",
      "It can be used for type traits",
      "All of the above"
    ],
    "correct": 3,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "Which of the following is true about template specialization syntax?",
    "options": [
      "It uses template<> syntax",
      "It provides custom implementation for specific types",
      "It can be partial or full",
      "All of the above"
    ],
    "correct": 3,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "Which of the following is true about template argument deduction rules?",
    "options": [
      "They follow specific priority rules",
      "They can be customized with traits",
      "They enable flexible template usage",
      "All of the above"
    ],
    "correct": 3,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "Which of the following is true about template instantiation models?",
    "options": [
      "They determine when templates are instantiated",
      "They can be explicit or implicit",
      "They affect compilation time",
      "All of the above"
    ],
    "correct": 3,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "Which of the following is true about template metaprogramming libraries?",
    "options": [
      "They provide reusable metaprogramming components",
      "They enable complex compile-time computations",
      "They include type traits and utilities",
      "All of the above"
    ],
    "correct": 3,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "Which of the following is true about template specialization vs template overloading?",
    "options": [
      "Specialization provides custom implementation for specific types",
      "Overloading creates different function templates",
      "Specialization is more specific than overloading",
      "All of the above"
    ],
    "correct": 3,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "Which of the following is true about template argument deduction for function templates?",
    "options": [
      "It deduces template arguments from function arguments",
      "It follows specific deduction rules",
      "It can be guided with explicit template arguments",
      "All of the above"
    ],
    "correct": 3,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "Which of the following is true about template specialization syntax and rules?",
    "options": [
      "It uses template<> syntax for full specialization",
      "It uses template<...> syntax for partial specialization",
      "It follows specific matching rules",
      "All of the above"
    ],
    "correct": 3,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "Which of the following is true about template metaprogramming and compile-time computations?",
    "options": [
      "It enables computations during compilation",
      "It can be used for optimization",
      "It provides type-level programming",
      "All of the above"
    ],
    "correct": 3,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "Which of the following is true about template metaprogramming and type traits?",
    "options": [
      "Type traits provide compile-time type information",
      "They enable template metaprogramming",
      "They include utilities for type manipulation",
      "All of the above"
    ],
    "correct": 3,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "Which of the following is true about template specialization and overloading resolution?",
    "options": [
      "Specialization is more specific than overloading",
      "Overloading follows function overload resolution rules",
      "Specialization provides custom implementation for specific types",
      "All of the above"
    ],
    "correct": 3,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "Which of the following is true about template metaprogramming and compile-time optimization?",
    "options": [
      "It enables computations during compilation",
      "It can improve runtime performance",
      "It provides type-level programming capabilities",
      "All of the above"
    ],
    "correct": 3,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "Which of the following is true about template argument deduction and SFINAE?",
    "options": [
      "SFINAE enables function overload resolution based on template arguments",
      "It works with template argument deduction",
      "It provides compile-time constraints",
      "All of the above"
    ],
    "correct": 3,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "Which of the following is true about template metaprogramming and type manipulation?",
    "options": [
      "It enables compile-time type computations",
      "It provides utilities for type manipulation",
      "It can be used for optimization",
      "All of the above"
    ],
    "correct": 3,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "Which of the following is true about template specialization and template instantiation?",
    "options": [
      "Specialization provides custom implementation for specific types",
      "Instantiation creates concrete types from template definitions",
      "Specialization can be partial or full",
      "All of the above"
    ],
    "correct": 3,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "Which of the following is true about template argument deduction and template specialization?",
    "options": [
      "Template argument deduction deduces arguments from function calls",
      "Template specialization provides custom implementation for specific types",
      "They work together to enable flexible template usage",
      "All of the above"
    ],
    "correct": 3,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "Which of the following is true about template specialization and template overloading in C++?",
    "options": [
      "Specialization provides custom implementation for specific types",
      "Overloading creates different function templates",
      "Specialization is more specific than overloading",
      "All of the above"
    ],
    "correct": 3,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "Which of the following is true about template metaprogramming and compile-time optimization in C++?",
    "options": [
      "It enables computations during compilation",
      "It can improve runtime performance",
      "It provides type-level programming capabilities",
      "All of the above"
    ],
    "correct": 3,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "Which of the following is true about template argument deduction and SFINAE in C++ templates?",
    "options": [
      "SFINAE enables function overload resolution based on template arguments",
      "It works with template argument deduction",
      "It provides compile-time constraints for template instantiation",
      "All of the above"
    ],
    "correct": 3,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "Which of the following is true about template metaprogramming and type traits in modern C++?",
    "options": [
      "Type traits provide compile-time type information and utilities",
      "They enable advanced template metaprogramming techniques",
      "They include utilities for type manipulation and inspection",
      "All of the above"
    ],
    "correct": 3,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "What is the output of:\ntemplate<typename T>\nT max(T a, T b) { return a>b?a:b; }\ncout << max(5, 10);",
    "options": [
      "5",
      "10",
      "15",
      "Compiler error"
    ],
    "correct": 1,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "What is the purpose of templates in C++?",
    "options": [
      "To create generic functions and classes",
      "To speed up compilation",
      "To reduce memory usage",
      "To define constant values"
    ],
    "correct": 0,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "What is template specialization?",
    "options": [
      "Defining a specific implementation of a template for a particular data type",
      "Creating a template with multiple parameters",
      "Inheriting from a template class",
      "Deleting a template"
    ],
    "correct": 0,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "Are function template parameters deduced?",
    "options": [
      "Yes, from arguments",
      "No, always explicit",
      "Only in C++17",
      "Never"
    ],
    "correct": 0,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "What is explicit template instantiation?",
    "options": [
      "Forcing template to create specific instance",
      "Automatic template generation",
      "Template with explicit keyword",
      "Template with no parameters"
    ],
    "correct": 0,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "What does ... mean in templates?",
    "options": [
      "Parameter pack",
      "Array",
      "Pointer",
      "Reference"
    ],
    "correct": 0,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "How to declare a class template?",
    "options": [
      "template<typename T> class",
      "class<T>",
      "template class<T>",
      "typename class T"
    ],
    "correct": 0,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "What are non-type template parameters?",
    "options": [
      "Compile-time constants as parameters",
      "Type parameters",
      "Class parameters",
      "Function parameters"
    ],
    "correct": 0,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "What are template default parameters?",
    "options": [
      "Parameters with default values",
      "Required parameters",
      "Runtime parameters",
      "Virtual parameters"
    ],
    "correct": 0,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "What are template template parameters?",
    "options": [
      "Template that accepts template as parameter",
      "Double template",
      "Nested template",
      "Template array"
    ],
    "correct": 0,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "What is a dependent type?",
    "options": [
      "Type depends on template parameter",
      "Independent type",
      "Built-in type",
      "Pointer type"
    ],
    "correct": 0,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "What is SFINAE?",
    "options": [
      "Substitution Failure Is Not An Error",
      "Simple Function Assignment",
      "Standard Function Interface",
      "Static Function Argument"
    ],
    "correct": 0,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "What is fold expression in C++17?",
    "options": [
      "Reduce parameter pack",
      "Fold code",
      "Loop template",
      "Array expansion"
    ],
    "correct": 0,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "What is template argument ordering?",
    "options": [
      "Specified before defaulted parameters",
      "Random order",
      "Reverse order",
      "No order required"
    ],
    "correct": 0,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "What are concepts in C++20?",
    "options": [
      "Constraints on template parameters",
      "Comments",
      "Concepts are classes",
      "Template ideas"
    ],
    "correct": 0,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "What is the difference between full and partial template specialization?",
    "options": [
      "Full specializes all parameters, partial some",
      "No difference",
      "Full is faster",
      "Partial is newer"
    ],
    "correct": 0,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "Which operator is used for dynamic casting in C++?",
    "options": [
      "static_cast",
      "dynamic_cast",
      "const_cast",
      "reinterpret_cast"
    ],
    "correct": 1,
    "category": "Type Casting",
    "type": "single"
  },
  {
    "question": "Which of the following is not a valid C++ casting operator?",
    "options": [
      "static_cast",
      "dynamic_cast",
      "explicit_cast",
      "reinterpret_cast"
    ],
    "correct": 2,
    "category": "Type Casting",
    "type": "single"
  },
  {
    "question": "What is the difference between 'static_cast' and 'dynamic_cast'?",
    "options": [
      "static_cast is compile-time, dynamic_cast is runtime",
      "dynamic_cast requires RTTI",
      "dynamic_cast works with polymorphism",
      "All of the above"
    ],
    "correct": 3,
    "category": "Type Casting",
    "type": "single"
  },
  {
    "question": "What is the difference between 'const_cast' and other casting operators?",
    "options": [
      "const_cast can remove const/volatile qualifiers",
      "const_cast is the only cast that can remove constness",
      "const_cast can be dangerous if misused",
      "All of the above"
    ],
    "correct": 3,
    "category": "Type Casting",
    "type": "single"
  },
  {
    "question": "What is the difference between 'static_cast' and 'reinterpret_cast'?",
    "options": [
      "static_cast is safer than reinterpret_cast",
      "reinterpret_cast can convert between unrelated types",
      "static_cast performs compile-time checks",
      "All of the above"
    ],
    "correct": 3,
    "category": "Type Casting",
    "type": "single"
  },
  {
    "question": "What is the difference between 'static' and 'dynamic' casting in terms of safety?",
    "options": [
      "static_cast is safer than dynamic_cast",
      "dynamic_cast performs runtime checks",
      "static_cast doesn't require RTTI",
      "All of the above"
    ],
    "correct": 3,
    "category": "Type Casting",
    "type": "single"
  },
  {
    "question": "What is the difference between 'const_cast' and 'static_cast' in terms of usage?",
    "options": [
      "const_cast can remove constness, static_cast cannot",
      "static_cast is safer than const_cast",
      "const_cast has limited use cases",
      "All of the above"
    ],
    "correct": 3,
    "category": "Type Casting",
    "type": "single"
  },
  {
    "question": "What is the difference between 'static_cast' and 'dynamic_cast' in terms of performance?",
    "options": [
      "static_cast is faster than dynamic_cast",
      "dynamic_cast requires runtime type information",
      "static_cast is resolved at compile time",
      "All of the above"
    ],
    "correct": 3,
    "category": "Type Casting",
    "type": "single"
  },
  {
    "question": "What is the output of:\nint x = 5;\nfloat y = (float)x / 2;\ncout << y;",
    "options": [
      "2",
      "2.0",
      "2.5",
      "Compiler error"
    ],
    "correct": 2,
    "category": "Type Conversion",
    "type": "single"
  },
  {
    "question": "What is the output of: cout << (5 + 'a');",
    "options": [
      "5a",
      "102",
      "5",
      "a"
    ],
    "correct": 1,
    "category": "Type Conversion",
    "type": "single"
  },
  {
    "question": "What is the output of:\nint a = 5, b = 10;\nint temp = a;\na = b;\nb = temp;\ncout << a << ' ' << b;",
    "options": [
      "5 10",
      "10 5",
      "10 10",
      "5 5"
    ],
    "correct": 1,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "What is the output of:\nint arr[3] = {10, 20, 30};\ncout << sizeof(arr);",
    "options": [
      "3",
      "12",
      "4",
      "Depends on system"
    ],
    "correct": 1,
    "category": "Arrays",
    "type": "single"
  },
  {
    "question": "What is the output of:\nint x = 100;\nwhile(x > 95) {\n  cout << x << ' ';\n  x--;\n}",
    "options": [
      "100",
      "100 99 98 97 96",
      "95",
      "Infinite loop"
    ],
    "correct": 1,
    "category": "Control Structures",
    "type": "single"
  },
  {
    "question": "What is the output of:\nfor(int i = 0; i < 3; i++) {\n  if(i == 1) break;\n  cout << i;\n}",
    "options": [
      "0",
      "01",
      "012",
      "Nothing"
    ],
    "correct": 0,
    "category": "Control Structures",
    "type": "single"
  },
  {
    "question": "What is the output of:\nint x = 5;\nswitch(x) {\n  case 5: cout << 'A';\n  case 6: cout << 'B';\n  default: cout << 'C';\n}",
    "options": [
      "A",
      "AB",
      "ABC",
      "C"
    ],
    "correct": 2,
    "category": "Control Structures",
    "type": "single"
  },
  {
    "question": "What is the output of:\nint x = 0;\ndo {\n  cout << x++;\n} while(x < 0);",
    "options": [
      "-1",
      "0",
      "Nothing",
      "Infinite loop"
    ],
    "correct": 1,
    "category": "Control Structures",
    "type": "single"
  },
  {
    "question": "What is the output of:\nint x = 10, y = 20;\ncout << (x < y ? x : y);",
    "options": [
      "10",
      "20",
      "0",
      "1"
    ],
    "correct": 0,
    "category": "Operators",
    "type": "single"
  },
  {
    "question": "What is the output of:\nint x = 7;\ncout << (x & 3);",
    "options": [
      "3",
      "7",
      "4",
      "21"
    ],
    "correct": 0,
    "category": "Operators",
    "type": "single"
  },
  {
    "question": "What is the output of:\nint x = 8;\ncout << (x | 3);",
    "options": [
      "8",
      "11",
      "3",
      "24"
    ],
    "correct": 1,
    "category": "Operators",
    "type": "single"
  },
  {
    "question": "What is the output of:\nint x = 15;\ncout << (x ^ 3);",
    "options": [
      "12",
      "15",
      "18",
      "45"
    ],
    "correct": 0,
    "category": "Operators",
    "type": "single"
  },
  {
    "question": "What is the output of:\nint x = -5;\ncout << abs(x);",
    "options": [
      "-5",
      "5",
      "0",
      "Compiler error"
    ],
    "correct": 1,
    "category": "Functions",
    "type": "single"
  },
  {
    "question": "What is the output of:\ndouble x = 3.7;\ncout << floor(x);",
    "options": [
      "3",
      "4",
      "3.7",
      "Compiler error"
    ],
    "correct": 0,
    "category": "Functions",
    "type": "single"
  },
  {
    "question": "What is the output of:\ndouble x = 3.2;\ncout << ceil(x);",
    "options": [
      "3",
      "4",
      "3.2",
      "Compiler error"
    ],
    "correct": 1,
    "category": "Functions",
    "type": "single"
  },
  {
    "question": "What is the output of:\nint x = pow(2, 3);\ncout << x;",
    "options": [
      "5",
      "6",
      "8",
      "9"
    ],
    "correct": 2,
    "category": "Functions",
    "type": "single"
  },
  {
    "question": "What is the output of:\nstring s = \"Hello\";\ns[0] = 'h';\ncout << s;",
    "options": [
      "Hello",
      "hello",
      "hHello",
      "Compiler error"
    ],
    "correct": 1,
    "category": "Strings",
    "type": "single"
  },
  {
    "question": "What is the output of:\nstring s = \"C++\";\ncout << s + \" Programming\";",
    "options": [
      "C++",
      "Programming",
      "C++ Programming",
      "Compiler error"
    ],
    "correct": 2,
    "category": "Strings",
    "type": "single"
  },
  {
    "question": "What is the output of:\nstring s = \"Test\";\ncout << s.empty();",
    "options": [
      "0",
      "1",
      "true",
      "false"
    ],
    "correct": 0,
    "category": "Strings",
    "type": "single"
  },
  {
    "question": "What is the output of:\nstring s = \"Hello\";\ns.append(\" World\");\ncout << s.length();",
    "options": [
      "5",
      "6",
      "11",
      "12"
    ],
    "correct": 2,
    "category": "Strings",
    "type": "single"
  },
  {
    "question": "What is the output of:\nint *p = nullptr;\nif(p == nullptr)\n  cout << \"Null\";\nelse\n  cout << \"Not Null\";",
    "options": [
      "Null",
      "Not Null",
      "0",
      "Compiler error"
    ],
    "correct": 0,
    "category": "Pointers",
    "type": "single"
  },
  {
    "question": "What is the output of:\nint x = 5;\nint *p = &x;\n*p = 10;\ncout << x;",
    "options": [
      "5",
      "10",
      "Address",
      "Compiler error"
    ],
    "correct": 1,
    "category": "Pointers",
    "type": "single"
  },
  {
    "question": "What is the output of:\nint arr[] = {5, 10, 15};\nint *p = arr + 1;\ncout << *p;",
    "options": [
      "5",
      "10",
      "15",
      "Compiler error"
    ],
    "correct": 1,
    "category": "Pointers",
    "type": "single"
  },
  {
    "question": "What is the output of:\nclass A { public: int x = 5; };\nA obj;\ncout << obj.x;",
    "options": [
      "0",
      "5",
      "Garbage",
      "Compiler error"
    ],
    "correct": 1,
    "category": "OOP",
    "type": "single"
  },
  {
    "question": "What is the output of:\nclass A { int x; public: A() { x = 10; } int get() { return x; } };\nA obj;\ncout << obj.get();",
    "options": [
      "0",
      "10",
      "Garbage",
      "Compiler error"
    ],
    "correct": 1,
    "category": "OOP",
    "type": "single"
  },
  {
    "question": "What is the output of:\nclass A { public: static int count; };\nint A::count = 0;\nA a, b, c;\nA::count = 3;\ncout << A::count;",
    "options": [
      "0",
      "1",
      "3",
      "Compiler error"
    ],
    "correct": 2,
    "category": "OOP",
    "type": "single"
  },
  {
    "question": "What is the output of:\nclass A { public: void show() { cout << \"A\"; } };\nclass B : public A { public: void show() { cout << \"B\"; } };\nB obj;\nobj.show();",
    "options": [
      "A",
      "B",
      "AB",
      "Compiler error"
    ],
    "correct": 1,
    "category": "OOP",
    "type": "single"
  },
  {
    "question": "What is the output of:\ntry {\n  int x = 10 / 0;\n} catch(int e) {\n  cout << \"Error\";\n}",
    "options": [
      "Error",
      "0",
      "Undefined behavior",
      "Compiler error"
    ],
    "correct": 2,
    "category": "Exceptions",
    "type": "single"
  },
  {
    "question": "What is the output of:\ntry {\n  throw 42;\n} catch(int x) {\n  cout << x;\n}",
    "options": [
      "0",
      "42",
      "Error",
      "Compiler error"
    ],
    "correct": 1,
    "category": "Exceptions",
    "type": "single"
  },
  {
    "question": "What is the output of:\ntry {\n  throw \"Error\";\n} catch(const char* msg) {\n  cout << msg;\n}",
    "options": [
      "Error",
      "0",
      "Nothing",
      "Compiler error"
    ],
    "correct": 0,
    "category": "Exceptions",
    "type": "single"
  },
  {
    "question": "What is the output of:\nvector<int> v;\nv.push_back(1);\nv.push_back(2);\nv.pop_back();\ncout << v.size();",
    "options": [
      "0",
      "1",
      "2",
      "3"
    ],
    "correct": 1,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "What is the output of:\nset<int> s;\ns.insert(1);\ns.insert(1);\ncout << s.size();",
    "options": [
      "0",
      "1",
      "2",
      "Undefined"
    ],
    "correct": 1,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "What is the output of:\nmap<int, string> m;\nm[1] = \"One\";\nm[2] = \"Two\";\ncout << m.size();",
    "options": [
      "0",
      "1",
      "2",
      "3"
    ],
    "correct": 2,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "What is the output of:\nqueue<int> q;\nq.push(10);\nq.push(20);\ncout << q.front();",
    "options": [
      "10",
      "20",
      "0",
      "Undefined"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "What is the output of:\nstack<int> st;\nst.push(5);\nst.push(10);\ncout << st.top();",
    "options": [
      "5",
      "10",
      "0",
      "Undefined"
    ],
    "correct": 1,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "What is the output of:\nauto x = 10;\ncout << typeid(x).name();",
    "options": [
      "int",
      "auto",
      "i",
      "Depends on compiler"
    ],
    "correct": 3,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is the output of:\nauto f = [](int x) { return x + 1; };\ncout << f(5);",
    "options": [
      "5",
      "6",
      "1",
      "Compiler error"
    ],
    "correct": 1,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is the output of:\nint arr[] = {1, 2, 3};\nint sum = 0;\nfor(auto x : arr) sum += x;\ncout << sum;",
    "options": [
      "0",
      "3",
      "6",
      "Compiler error"
    ],
    "correct": 2,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is the output of:\nstd::unique_ptr<int> p(new int(5));\ncout << *p;",
    "options": [
      "0",
      "5",
      "Address",
      "Compiler error"
    ],
    "correct": 1,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is the output of:\ntemplate<typename T>\nvoid print(T val) { cout << val; }\nprint(100);",
    "options": [
      "0",
      "100",
      "T",
      "Compiler error"
    ],
    "correct": 1,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "What is the output of:\ntemplate<int N>\nstruct Factorial {\n  enum { value = N * Factorial<N-1>::value };\n};\ntemplate<>\nstruct Factorial<0> { enum { value = 1 }; };\ncout << Factorial<5>::value;",
    "options": [
      "5",
      "25",
      "120",
      "Compiler error"
    ],
    "correct": 2,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "What is the output of:\n#define MAX(a,b) ((a)>(b)?(a):(b))\ncout << MAX(3, 5);",
    "options": [
      "3",
      "5",
      "8",
      "Compiler error"
    ],
    "correct": 1,
    "category": "Preprocessor",
    "type": "single"
  },
  {
    "question": "What is the output of:\n#define DEBUG\n#ifdef DEBUG\ncout << \"Debug mode\";\n#endif",
    "options": [
      "Nothing",
      "Debug mode",
      "0",
      "Compiler error"
    ],
    "correct": 1,
    "category": "Preprocessor",
    "type": "single"
  },
  {
    "question": "What is the output of:\nint x = 10;\nint &ref = x;\nref = 20;\ncout << x;",
    "options": [
      "10",
      "20",
      "Garbage",
      "Compiler error"
    ],
    "correct": 1,
    "category": "References",
    "type": "single"
  },
  {
    "question": "What is the output of:\nint x = 5;\nconst int &ref = x;\nx = 10;\ncout << ref;",
    "options": [
      "5",
      "10",
      "Garbage",
      "Compiler error"
    ],
    "correct": 1,
    "category": "References",
    "type": "single"
  },
  {
    "question": "What is the output of:\nenum Color { RED, GREEN, BLUE };\nColor c = GREEN;\ncout << c;",
    "options": [
      "0",
      "1",
      "GREEN",
      "Compiler error"
    ],
    "correct": 1,
    "category": "Enums",
    "type": "single"
  },
  {
    "question": "What is the output of:\nenum class Status { OK = 200, ERROR = 404 };\ncout << (int)Status::OK;",
    "options": [
      "0",
      "200",
      "OK",
      "Compiler error"
    ],
    "correct": 1,
    "category": "Enums",
    "type": "single"
  },
  {
    "question": "What is the output of:\nstruct Point { int x, y; };\nPoint p = {10, 20};\ncout << p.x + p.y;",
    "options": [
      "10",
      "20",
      "30",
      "Compiler error"
    ],
    "correct": 2,
    "category": "Structures",
    "type": "single"
  },
  {
    "question": "What is the output of:\nunion Data { int i; float f; };\nData d;\nd.i = 10;\ncout << d.i;",
    "options": [
      "0",
      "10",
      "Garbage",
      "Compiler error"
    ],
    "correct": 1,
    "category": "Unions",
    "type": "single"
  },
  {
    "question": "What is the output of:\ntypedef int Integer;\nInteger x = 100;\ncout << x;",
    "options": [
      "0",
      "100",
      "Integer",
      "Compiler error"
    ],
    "correct": 1,
    "category": "Type Aliases",
    "type": "single"
  },
  {
    "question": "What is the output of:\nusing Number = int;\nNumber n = 50;\ncout << n;",
    "options": [
      "0",
      "50",
      "Number",
      "Compiler error"
    ],
    "correct": 1,
    "category": "Type Aliases",
    "type": "single"
  },
  {
    "question": "What is the output of:\nconst int MAX = 100;\ncout << MAX;",
    "options": [
      "0",
      "100",
      "MAX",
      "Compiler error"
    ],
    "correct": 1,
    "category": "Constants",
    "type": "single"
  },
  {
    "question": "What is the output of:\nconstexpr int square(int x) { return x * x; }\ncout << square(5);",
    "options": [
      "5",
      "10",
      "25",
      "Compiler error"
    ],
    "correct": 2,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is the output of:\nint x = 10;\nint y = 20;\nstd::swap(x, y);\ncout << x << ' ' << y;",
    "options": [
      "10 20",
      "20 10",
      "10 10",
      "20 20"
    ],
    "correct": 1,
    "category": "Functions",
    "type": "single"
  },
  {
    "question": "What is the output of:\nvector<int> v = {1, 2, 3, 4, 5};\nauto it = v.begin();\ncout << *it;",
    "options": [
      "0",
      "1",
      "5",
      "Compiler error"
    ],
    "correct": 1,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "What is the output of:\nvector<int> v = {1, 2, 3};\nv.clear();\ncout << v.empty();",
    "options": [
      "0",
      "1",
      "false",
      "true"
    ],
    "correct": 1,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "What is the output of:\nstring s = \"123\";\nint n = stoi(s);\ncout << n + 7;",
    "options": [
      "123",
      "130",
      "1237",
      "Compiler error"
    ],
    "correct": 1,
    "category": "Strings",
    "type": "single"
  },
  {
    "question": "What is the output of:\nint x = 42;\nstring s = to_string(x);\ncout << s.length();",
    "options": [
      "0",
      "2",
      "42",
      "Compiler error"
    ],
    "correct": 1,
    "category": "Strings",
    "type": "single"
  },
  {
    "question": "What is the output of:\ndouble d = 3.14159;\ncout << fixed << setprecision(2) << d;",
    "options": [
      "3",
      "3.14",
      "3.1416",
      "Compiler error"
    ],
    "correct": 1,
    "category": "I/O",
    "type": "single"
  },
  {
    "question": "What is the output of:\nbool flag = true;\ncout << boolalpha << flag;",
    "options": [
      "0",
      "1",
      "true",
      "flag"
    ],
    "correct": 2,
    "category": "I/O",
    "type": "single"
  },
  {
    "question": "What is the output of:\nint x = 255;\ncout << hex << x;",
    "options": [
      "255",
      "ff",
      "0xff",
      "Depends on settings"
    ],
    "correct": 1,
    "category": "I/O",
    "type": "single"
  },
  {
    "question": "What is the output of:\nint x = 8;\ncout << oct << x;",
    "options": [
      "8",
      "10",
      "11",
      "Compiler error"
    ],
    "correct": 1,
    "category": "I/O",
    "type": "single"
  },
  {
    "question": "What is the output of:\nint arr[] = {10, 20, 30};\nint *p = arr;\ncout << *(p++);",
    "options": [
      "10",
      "20",
      "30",
      "Address"
    ],
    "correct": 0,
    "category": "Pointers",
    "type": "single"
  },
  {
    "question": "What is the output of:\nint x = 5;\nint &&rref = std::move(x);\nrref = 10;\ncout << x;",
    "options": [
      "5",
      "10",
      "Undefined",
      "Compiler error"
    ],
    "correct": 1,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is the output of:\nclass A { public: virtual void f() { cout << \"A\"; } };\nclass B : public A { public: void f() override { cout << \"B\"; } };\nA *p = new B();\np->f();",
    "options": [
      "A",
      "B",
      "AB",
      "Compiler error"
    ],
    "correct": 1,
    "category": "Polymorphism",
    "type": "single"
  },
  {
    "question": "What is the output of:\nstd::pair<int, string> p = {1, \"One\"};\ncout << p.first << p.second;",
    "options": [
      "1",
      "One",
      "1One",
      "Compiler error"
    ],
    "correct": 2,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "What is the output of:\ntuple<int, double, string> t = {1, 2.5, \"Test\"};\ncout << get<2>(t);",
    "options": [
      "1",
      "2.5",
      "Test",
      "Compiler error"
    ],
    "correct": 2,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "What is the output of:\noptional<int> opt = 10;\nif(opt) cout << *opt;",
    "options": [
      "0",
      "10",
      "Nothing",
      "Compiler error"
    ],
    "correct": 1,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is the output of:\nvariant<int, double> v = 3.14;\ncout << get<double>(v);",
    "options": [
      "0",
      "3",
      "3.14",
      "Compiler error"
    ],
    "correct": 2,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is the diamond problem in multiple inheritance?",
    "options": [
      "Ambiguity when two base classes have same member",
      "Memory diamond shape",
      "Diamond operator",
      "Pointer diamond"
    ],
    "correct": 0,
    "category": "OOP",
    "type": "single"
  },
  {
    "question": "How does virtual inheritance solve the diamond problem?",
    "options": [
      "Creates single instance of common base",
      "Removes inheritance",
      "Makes all virtual",
      "Prevents multiple inheritance"
    ],
    "correct": 0,
    "category": "OOP",
    "type": "single"
  },
  {
    "question": "What is the size of an empty class in C++?",
    "options": [
      "0 bytes",
      "1 byte",
      "4 bytes",
      "Undefined"
    ],
    "correct": 1,
    "category": "OOP",
    "type": "single"
  },
  {
    "question": "Can we have virtual constructors in C++?",
    "options": [
      "No, constructors cannot be virtual",
      "Yes",
      "Only in derived classes",
      "Only with virtual keyword"
    ],
    "correct": 0,
    "category": "OOP",
    "type": "single"
  },
  {
    "question": "What is object slicing in C++?",
    "options": [
      "Loss of derived class data when assigned to base",
      "Cutting objects",
      "Dividing memory",
      "Pointer slicing"
    ],
    "correct": 0,
    "category": "OOP",
    "type": "single"
  },
  {
    "question": "What is RAII principle in C++?",
    "options": [
      "Resource Acquisition Is Initialization",
      "Random Access In Implementation",
      "Resource Allocation In Inheritance",
      "None"
    ],
    "correct": 0,
    "category": "OOP",
    "type": "single"
  },
  {
    "question": "Can static member functions access non-static members?",
    "options": [
      "No, they cannot",
      "Yes, always",
      "Only with this pointer",
      "Only in derived class"
    ],
    "correct": 0,
    "category": "OOP",
    "type": "single"
  },
  {
    "question": "What is covariant return type?",
    "options": [
      "Derived class can return more specific type",
      "Same return type",
      "Void return",
      "Template return"
    ],
    "correct": 0,
    "category": "OOP",
    "type": "single"
  },
  {
    "question": "Can we overload const member functions?",
    "options": [
      "Yes, based on const qualifier",
      "No",
      "Only static",
      "Only virtual"
    ],
    "correct": 0,
    "category": "OOP",
    "type": "single"
  },
  {
    "question": "What is early binding in C++?",
    "options": [
      "Compile-time function resolution",
      "Runtime binding",
      "Late binding",
      "Dynamic binding"
    ],
    "correct": 0,
    "category": "OOP",
    "type": "single"
  },
  {
    "question": "What is late binding in C++?",
    "options": [
      "Runtime polymorphism using virtual",
      "Compile-time binding",
      "Early binding",
      "Static binding"
    ],
    "correct": 0,
    "category": "OOP",
    "type": "single"
  },
  {
    "question": "Can we have pure virtual destructors?",
    "options": [
      "Yes, but must provide definition",
      "No",
      "Only in abstract classes",
      "Only in interfaces"
    ],
    "correct": 0,
    "category": "OOP",
    "type": "single"
  },
  {
    "question": "What is vtable in C++?",
    "options": [
      "Virtual function table for polymorphism",
      "Variable table",
      "Value table",
      "Vector table"
    ],
    "correct": 0,
    "category": "OOP",
    "type": "single"
  },
  {
    "question": "What is vptr in C++?",
    "options": [
      "Pointer to vtable",
      "Virtual pointer type",
      "Value pointer",
      "Vector pointer"
    ],
    "correct": 0,
    "category": "OOP",
    "type": "single"
  },
  {
    "question": "Can we call virtual function in constructor?",
    "options": [
      "Yes, but calls base version",
      "No, compiler error",
      "Yes, calls derived version",
      "Only in destructor"
    ],
    "correct": 0,
    "category": "OOP",
    "type": "single"
  },
  {
    "question": "What is name hiding in inheritance?",
    "options": [
      "Derived class hides base class members",
      "Private members",
      "Protected members",
      "Public members"
    ],
    "correct": 0,
    "category": "OOP",
    "type": "single"
  },
  {
    "question": "Can we inherit constructors in C++11?",
    "options": [
      "Yes, using 'using' keyword",
      "No",
      "Only default constructor",
      "Only parameterized"
    ],
    "correct": 0,
    "category": "OOP",
    "type": "single"
  },
  {
    "question": "What is the rule of three in C++?",
    "options": [
      "Define copy constructor, copy assignment, destructor",
      "Three constructors",
      "Three destructors",
      "Three operators"
    ],
    "correct": 0,
    "category": "OOP",
    "type": "single"
  },
  {
    "question": "What is the rule of five in C++11?",
    "options": [
      "Add move constructor and move assignment to rule of three",
      "Five constructors",
      "Five operators",
      "Five members"
    ],
    "correct": 0,
    "category": "OOP",
    "type": "single"
  },
  {
    "question": "What is rule of zero?",
    "options": [
      "Let compiler generate all special members",
      "No special members",
      "Zero constructors",
      "No destructor"
    ],
    "correct": 0,
    "category": "OOP",
    "type": "single"
  },
  {
    "question": "Can we overload new and delete operators?",
    "options": [
      "Yes, for custom memory management",
      "No",
      "Only new",
      "Only delete"
    ],
    "correct": 0,
    "category": "OOP",
    "type": "single"
  },
  {
    "question": "What is placement new in C++?",
    "options": [
      "Construct object at specific memory location",
      "New placement",
      "Memory placement",
      "Pointer placement"
    ],
    "correct": 0,
    "category": "Memory Management",
    "type": "single"
  },
  {
    "question": "What is copy elision in C++?",
    "options": [
      "Optimization to avoid unnecessary copies",
      "Copy prevention",
      "Elision operator",
      "Copy error"
    ],
    "correct": 0,
    "category": "OOP",
    "type": "single"
  },
  {
    "question": "What is RVO (Return Value Optimization)?",
    "options": [
      "Avoid copy when returning by value",
      "Return void optimization",
      "Return value operator",
      "Recursive value optimization"
    ],
    "correct": 0,
    "category": "OOP",
    "type": "single"
  },
  {
    "question": "What is NRVO (Named Return Value Optimization)?",
    "options": [
      "Optimize named return values",
      "Non-return value optimization",
      "New RVO",
      "None"
    ],
    "correct": 0,
    "category": "OOP",
    "type": "single"
  },
  {
    "question": "Can we delete a void pointer?",
    "options": [
      "Undefined behavior, should cast first",
      "Yes, safe",
      "No, compiler error",
      "Only with delete[]"
    ],
    "correct": 0,
    "category": "Pointers",
    "type": "single"
  },
  {
    "question": "What is aggregate initialization?",
    "options": [
      "Initialize arrays/structs with braces",
      "Aggregate functions",
      "Sum initialization",
      "Group initialization"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "What is list initialization in C++11?",
    "options": [
      "Initialize using {}",
      "Initialize lists",
      "Array initialization",
      "Vector initialization"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is uniform initialization?",
    "options": [
      "Consistent {} syntax for all types",
      "Same values",
      "Universal initialization",
      "Unit initialization"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is narrowing conversion?",
    "options": [
      "Conversion that loses information",
      "Making variables smaller",
      "Pointer narrowing",
      "Type narrowing"
    ],
    "correct": 0,
    "category": "Type Casting",
    "type": "single"
  },
  {
    "question": "Does {} initialization prevent narrowing?",
    "options": [
      "Yes, causes error",
      "No",
      "Only in C++11",
      "Only for integers"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is the most vexing parse?",
    "options": [
      "Ambiguity between function declaration and object creation",
      "Complex parsing",
      "Parse error",
      "Vexing syntax"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "What is argument-dependent lookup (ADL)?",
    "options": [
      "Lookup functions in argument namespaces",
      "Argument dependency",
      "Dependent arguments",
      "Lookup arguments"
    ],
    "correct": 0,
    "category": "Namespaces",
    "type": "single"
  },
  {
    "question": "What is Koenig lookup?",
    "options": [
      "Another name for ADL",
      "King lookup",
      "Keyword lookup",
      "K-algorithm"
    ],
    "correct": 0,
    "category": "Namespaces",
    "type": "single"
  },
  {
    "question": "Can we forward declare an enum?",
    "options": [
      "Yes, in C++11 with fixed underlying type",
      "No",
      "Only unscoped enums",
      "Only scoped enums"
    ],
    "correct": 0,
    "category": "Enums",
    "type": "single"
  },
  {
    "question": "What is scoped enum in C++11?",
    "options": [
      "enum class with strong typing",
      "Class scope enum",
      "Scoped values",
      "Enum in scope"
    ],
    "correct": 0,
    "category": "Enums",
    "type": "single"
  },
  {
    "question": "Can we specify underlying type for enum?",
    "options": [
      "Yes, using enum : type syntax",
      "No",
      "Only int",
      "Only char"
    ],
    "correct": 0,
    "category": "Enums",
    "type": "single"
  },
  {
    "question": "What is the underlying type of enum?",
    "options": [
      "Implementation-defined integral type",
      "Always int",
      "Always char",
      "Always long"
    ],
    "correct": 0,
    "category": "Enums",
    "type": "single"
  },
  {
    "question": "What is designated initialization in C++20?",
    "options": [
      "Initialize struct members by name",
      "Design patterns",
      "Designated pointers",
      "Named initialization"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is structured binding in C++17?",
    "options": [
      "Unpack tuple/struct into variables",
      "Structure binding",
      "Struct pointers",
      "Bound structures"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is template metaprogramming?",
    "options": [
      "Compile-time computation using templates",
      "Template programming",
      "Meta classes",
      "Programming metadata"
    ],
    "correct": 0,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "What is SFINAE principle?",
    "options": [
      "Substitution Failure Is Not An Error",
      "Specific Function Arguments Not Evaluated",
      "Static Function Implementation",
      "None"
    ],
    "correct": 0,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "What is enable_if used for?",
    "options": [
      "Conditional template instantiation",
      "Enable functions",
      "If statements",
      "Enable variables"
    ],
    "correct": 0,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "What is decltype in C++11?",
    "options": [
      "Deduce type of expression",
      "Declare type",
      "Delete type",
      "Default type"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is declval used for?",
    "options": [
      "Get rvalue reference for decltype without constructor",
      "Declare value",
      "Default value",
      "Delete value"
    ],
    "correct": 0,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "What is std::decay?",
    "options": [
      "Remove references and cv-qualifiers",
      "Decrease type",
      "Decay pointer",
      "Time decay"
    ],
    "correct": 0,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "What are variadic templates?",
    "options": [
      "Templates accepting variable number of arguments",
      "Variable templates",
      "Varying templates",
      "Array templates"
    ],
    "correct": 0,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "What is parameter pack?",
    "options": [
      "Template parameter that accepts multiple arguments",
      "Pack parameters",
      "Parameter array",
      "Packed values"
    ],
    "correct": 0,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "What is pack expansion?",
    "options": [
      "Expand parameter pack",
      "Pack values",
      "Expand arrays",
      "Parameter expansion"
    ],
    "correct": 0,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "What is if constexpr in C++17?",
    "options": [
      "Compile-time if statement",
      "Constant if",
      "If expression",
      "Constexpr condition"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is consteval in C++20?",
    "options": [
      "Immediate function, must be compile-time",
      "Constant evaluation",
      "Evaluate constant",
      "Constexpr evaluation"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is constinit in C++20?",
    "options": [
      "Ensure compile-time initialization",
      "Constant initialization",
      "Initialize constant",
      "Init constant"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is type traits in C++?",
    "options": [
      "Compile-time type information",
      "Type characteristics",
      "Trait classes",
      "Type features"
    ],
    "correct": 0,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "What is std::is_integral?",
    "options": [
      "Check if type is integral",
      "Integer check",
      "Integral type",
      "Is integer"
    ],
    "correct": 0,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "What is std::is_same?",
    "options": [
      "Check if two types are identical",
      "Same value",
      "Same variable",
      "Identity check"
    ],
    "correct": 0,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "What is std::conditional?",
    "options": [
      "Select type based on condition",
      "Conditional statement",
      "If type",
      "Type condition"
    ],
    "correct": 0,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "What is std::common_type?",
    "options": [
      "Determine common type of multiple types",
      "Common values",
      "Type union",
      "Shared type"
    ],
    "correct": 0,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "What is template template parameter?",
    "options": [
      "Template parameter that is itself a template",
      "Double template",
      "Nested template",
      "Template of template"
    ],
    "correct": 0,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "What is class template argument deduction (CTAD)?",
    "options": [
      "Deduce template arguments from constructor in C++17",
      "Class argument deduction",
      "Template class argument",
      "Deduction class"
    ],
    "correct": 0,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "What is deduction guide?",
    "options": [
      "Help compiler deduce template arguments",
      "Guide function",
      "Deduction function",
      "Template guide"
    ],
    "correct": 0,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "What is alias template?",
    "options": [
      "Template typedef using 'using'",
      "Alias type",
      "Template name",
      "Type alias"
    ],
    "correct": 0,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "What is variable template in C++14?",
    "options": [
      "Template for variables",
      "Variable template",
      "Templated variable",
      "Var template"
    ],
    "correct": 0,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "What is concepts in C++20?",
    "options": [
      "Named requirements for template parameters",
      "Concept classes",
      "Template concepts",
      "Type concepts"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is requires clause?",
    "options": [
      "Specify template constraints",
      "Require function",
      "Required parameters",
      "Constraint clause"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is requires expression?",
    "options": [
      "Check if expression is valid",
      "Expression requirement",
      "Required expression",
      "Check expression"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is abbreviated function template in C++20?",
    "options": [
      "Use auto for template parameters",
      "Short template",
      "Brief template",
      "Quick template"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is dependent name?",
    "options": [
      "Name that depends on template parameter",
      "Dependent type",
      "Name dependency",
      "Template name"
    ],
    "correct": 0,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "When to use typename keyword in templates?",
    "options": [
      "Before dependent qualified type names",
      "All types",
      "Type names",
      "Name types"
    ],
    "correct": 0,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "What is two-phase name lookup?",
    "options": [
      "Template instantiation lookup in two phases",
      "Double lookup",
      "Phase lookup",
      "Two lookups"
    ],
    "correct": 0,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "What is extern template?",
    "options": [
      "Prevent implicit template instantiation",
      "External template",
      "Outside template",
      "Remote template"
    ],
    "correct": 0,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "What is template recursion limit?",
    "options": [
      "Compiler limit on recursive template instantiation",
      "Recursion depth",
      "Template depth",
      "Instantiation limit"
    ],
    "correct": 0,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "What is std::invoke in C++17?",
    "options": [
      "Uniformly invoke callables",
      "Invoke function",
      "Call invoke",
      "Invocation"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is std::apply in C++17?",
    "options": [
      "Apply function to tuple",
      "Apply operation",
      "Function application",
      "Tuple apply"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is std::make_from_tuple in C++17?",
    "options": [
      "Construct object from tuple",
      "Make tuple",
      "Tuple construction",
      "From tuple"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is perfect forwarding?",
    "options": [
      "Forward arguments preserving value category",
      "Perfect forward",
      "Forward perfect",
      "Complete forwarding"
    ],
    "correct": 0,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "What is std::forward?",
    "options": [
      "Cast to original value category",
      "Forward function",
      "Move forward",
      "Forward cast"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is universal reference?",
    "options": [
      "T&& in template context",
      "Any reference",
      "Universal pointer",
      "Generic reference"
    ],
    "correct": 0,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "What is reference collapsing?",
    "options": [
      "Rules for combining references",
      "Reference collapse",
      "Collapse references",
      "Reference rules"
    ],
    "correct": 0,
    "category": "Templates",
    "type": "single"
  },
  {
    "question": "What is the difference between vector and array?",
    "options": [
      "vector is dynamic, array is fixed size",
      "No difference",
      "array is dynamic",
      "vector is fixed"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "What is emplace_back vs push_back?",
    "options": [
      "emplace_back constructs in-place",
      "Same",
      "push_back is faster",
      "emplace is slower"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "What is std::array in C++11?",
    "options": [
      "Fixed-size array with STL interface",
      "Dynamic array",
      "Array class",
      "Standard array"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "What is capacity vs size in vector?",
    "options": [
      "capacity is allocated memory, size is element count",
      "Same",
      "capacity is size",
      "size is capacity"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "What is vector reserve?",
    "options": [
      "Pre-allocate memory without constructing elements",
      "Reserve elements",
      "Allocate vector",
      "Memory reserve"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "What is vector shrink_to_fit?",
    "options": [
      "Reduce capacity to fit size",
      "Shrink vector",
      "Fit capacity",
      "Reduce vector"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "What is the complexity of vector insert at end?",
    "options": [
      "O(1) amortized",
      "O(n)",
      "O(log n)",
      "O(n^2)"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "What is the complexity of vector insert at beginning?",
    "options": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n log n)"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "What is list in STL?",
    "options": [
      "Doubly linked list",
      "Singly linked list",
      "Array list",
      "Vector list"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "What is forward_list in STL?",
    "options": [
      "Singly linked list",
      "Doubly linked list",
      "Forward array",
      "List forward"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "What is the advantage of list over vector?",
    "options": [
      "O(1) insertion/deletion anywhere",
      "Faster access",
      "Less memory",
      "More features"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "What is deque implementation?",
    "options": [
      "Array of arrays (chunks)",
      "Doubly linked list",
      "Single array",
      "Binary tree"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "What is unordered_map implementation?",
    "options": [
      "Hash table",
      "Binary tree",
      "Array",
      "Linked list"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "What is map implementation?",
    "options": [
      "Red-black tree (balanced BST)",
      "Hash table",
      "Array",
      "Linked list"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "What is multimap?",
    "options": [
      "Map allowing duplicate keys",
      "Multiple maps",
      "Many maps",
      "Map array"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "What is multiset?",
    "options": [
      "Set allowing duplicate values",
      "Multiple sets",
      "Many sets",
      "Set array"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "What is unordered_set implementation?",
    "options": [
      "Hash table",
      "Binary tree",
      "Array",
      "Linked list"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "What is set implementation?",
    "options": [
      "Red-black tree",
      "Hash table",
      "Array",
      "Linked list"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "What is priority_queue implementation?",
    "options": [
      "Heap (max heap by default)",
      "Queue",
      "Stack",
      "Tree"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "How to create min heap with priority_queue?",
    "options": [
      "Use greater<T> comparator",
      "Use less<T>",
      "Use min_heap",
      "Use heap"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "What is std::make_heap?",
    "options": [
      "Convert range to heap",
      "Make heap structure",
      "Create heap",
      "Build heap"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "What is std::sort complexity?",
    "options": [
      "O(n log n) average",
      "O(n)",
      "O(log n)",
      "O(n^2)"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "What algorithm does std::sort use?",
    "options": [
      "Introsort (quicksort + heapsort + insertion sort)",
      "Quicksort only",
      "Mergesort",
      "Heapsort"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "What is std::stable_sort?",
    "options": [
      "Sort preserving relative order of equal elements",
      "Stable algorithm",
      "Safe sort",
      "Sorted stable"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "What is std::partial_sort?",
    "options": [
      "Sort only first n elements",
      "Partially sorted",
      "Some sort",
      "Half sort"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "What is std::nth_element?",
    "options": [
      "Partially sort so nth element is in position",
      "Get nth element",
      "Sort nth",
      "Element sort"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "What is std::lower_bound?",
    "options": [
      "First position where element can be inserted",
      "Lower value",
      "Minimum bound",
      "Low bound"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "What is std::upper_bound?",
    "options": [
      "Last position where element can be inserted",
      "Upper value",
      "Maximum bound",
      "High bound"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "What is std::binary_search?",
    "options": [
      "Check if element exists in sorted range",
      "Binary search algorithm",
      "Search binary",
      "Binary find"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "What is std::equal_range?",
    "options": [
      "Get range of equal elements",
      "Equal values",
      "Range equal",
      "Same range"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "What is std::transform?",
    "options": [
      "Apply function to range",
      "Transform values",
      "Change elements",
      "Modify range"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "What is std::accumulate?",
    "options": [
      "Sum or reduce range with operation",
      "Accumulate values",
      "Add elements",
      "Sum range"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "What is std::for_each?",
    "options": [
      "Apply function to each element",
      "For loop",
      "Each element",
      "Loop each"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "What is std::copy_if?",
    "options": [
      "Copy elements satisfying predicate",
      "Copy if condition",
      "Conditional copy",
      "If copy"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "What is std::remove_if?",
    "options": [
      "Remove elements satisfying predicate",
      "Remove condition",
      "Conditional remove",
      "Delete if"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "What is the erase-remove idiom?",
    "options": [
      "Use remove then erase to delete elements",
      "Erase and remove",
      "Remove erase",
      "Delete pattern"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "What is std::unique?",
    "options": [
      "Remove consecutive duplicates",
      "Make unique",
      "Unique values",
      "Remove duplicates"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "What is std::partition?",
    "options": [
      "Reorder so predicate-true come first",
      "Partition array",
      "Divide range",
      "Split elements"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "What is std::rotate?",
    "options": [
      "Rotate elements in range",
      "Rotate array",
      "Circular shift",
      "Shift rotate"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "What is std::next_permutation?",
    "options": [
      "Generate next lexicographic permutation",
      "Next order",
      "Permute next",
      "Next arrangement"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "What is rvalue in C++?",
    "options": [
      "Temporary value",
      "Right value",
      "Return value",
      "Real value"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is lvalue in C++?",
    "options": [
      "Value with address",
      "Left value",
      "Local value",
      "Long value"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is xvalue in C++11?",
    "options": [
      "Expiring value (rvalue with identity)",
      "X value",
      "Extra value",
      "External value"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is prvalue in C++11?",
    "options": [
      "Pure rvalue",
      "Previous rvalue",
      "Primary rvalue",
      "Private rvalue"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is glvalue in C++11?",
    "options": [
      "Generalized lvalue",
      "Global lvalue",
      "General lvalue",
      "Good lvalue"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is move constructor?",
    "options": [
      "Constructor taking rvalue reference",
      "Move object",
      "Moving constructor",
      "Constructor move"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is move assignment operator?",
    "options": [
      "Assignment operator taking rvalue reference",
      "Move operator",
      "Moving assignment",
      "Assign move"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is std::unique_ptr?",
    "options": [
      "Smart pointer with unique ownership",
      "Unique pointer",
      "Single pointer",
      "One pointer"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is std::shared_ptr?",
    "options": [
      "Smart pointer with shared ownership",
      "Shared pointer",
      "Multiple pointer",
      "Common pointer"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is std::weak_ptr?",
    "options": [
      "Non-owning reference to shared_ptr",
      "Weak pointer",
      "Temporary pointer",
      "Light pointer"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is std::make_unique in C++14?",
    "options": [
      "Create unique_ptr",
      "Make unique",
      "Unique factory",
      "Create unique"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is std::make_shared?",
    "options": [
      "Create shared_ptr",
      "Make shared",
      "Shared factory",
      "Create shared"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "Why prefer make_shared over new?",
    "options": [
      "Single allocation for object and control block",
      "Faster",
      "Safer",
      "Better"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is circular reference problem with shared_ptr?",
    "options": [
      "Cyclic references prevent deallocation",
      "Circular pointer",
      "Reference circle",
      "Loop reference"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "How does weak_ptr solve circular reference?",
    "options": [
      "Doesn't increase reference count",
      "Breaks circle",
      "Weak reference",
      "No ownership"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is lambda expression?",
    "options": [
      "Anonymous function object",
      "Lambda function",
      "Function lambda",
      "Anonymous lambda"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is lambda capture?",
    "options": [
      "Access outer scope variables",
      "Capture variables",
      "Lambda variables",
      "Scope capture"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is capture by value [=]?",
    "options": [
      "Capture all by copy",
      "Value capture",
      "Copy capture",
      "All values"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is capture by reference [&]?",
    "options": [
      "Capture all by reference",
      "Reference capture",
      "Ref capture",
      "All references"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is init capture in C++14?",
    "options": [
      "Initialize variable in capture",
      "Capture init",
      "Initial capture",
      "Init variable"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is generic lambda in C++14?",
    "options": [
      "Lambda with auto parameters",
      "Generic function",
      "Template lambda",
      "Auto lambda"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is std::function?",
    "options": [
      "Type-erased wrapper for callables",
      "Function wrapper",
      "Callable function",
      "Function type"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is std::bind?",
    "options": [
      "Bind arguments to callable",
      "Bind function",
      "Function bind",
      "Bind parameters"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is auto return type deduction in C++14?",
    "options": [
      "Deduce function return type from return",
      "Auto return",
      "Return deduction",
      "Deduced return"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is trailing return type?",
    "options": [
      "Specify return type after parameter list",
      "Return trailing",
      "Trailing type",
      "After return"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is std::optional in C++17?",
    "options": [
      "Type that may or may not contain value",
      "Optional value",
      "Maybe type",
      "Nullable type"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is std::variant in C++17?",
    "options": [
      "Type-safe union",
      "Variant type",
      "Union variant",
      "Type variant"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is std::any in C++17?",
    "options": [
      "Type-safe container for any type",
      "Any type",
      "Universal container",
      "Generic any"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is std::string_view in C++17?",
    "options": [
      "Non-owning view of string",
      "String view",
      "View string",
      "String reference"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is std::filesystem in C++17?",
    "options": [
      "Library for file system operations",
      "File system",
      "Filesystem library",
      "File operations"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is std::span in C++20?",
    "options": [
      "Non-owning view of contiguous sequence",
      "Span view",
      "Sequence span",
      "Array span"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is three-way comparison operator <=> in C++20?",
    "options": [
      "Spaceship operator, returns ordering",
      "Three way compare",
      "Compare operator",
      "Ordering operator"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is designated initializers in C++20?",
    "options": [
      "Initialize struct members by name",
      "Named init",
      "Designated init",
      "Member init"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is std::ranges in C++20?",
    "options": [
      "Range-based algorithms and views",
      "Range library",
      "Ranges algorithms",
      "Range operations"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is coroutine in C++20?",
    "options": [
      "Function that can suspend and resume",
      "Concurrent routine",
      "Co function",
      "Routine co"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is co_await in C++20?",
    "options": [
      "Suspend coroutine until awaitable ready",
      "Wait co",
      "Await coroutine",
      "Co wait"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is co_yield in C++20?",
    "options": [
      "Suspend coroutine and return value",
      "Yield co",
      "Co return",
      "Yield coroutine"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is co_return in C++20?",
    "options": [
      "Return from coroutine",
      "Co return value",
      "Return coroutine",
      "Coroutine return"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is module in C++20?",
    "options": [
      "Better alternative to header files",
      "Module system",
      "Import module",
      "Module header"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is std::thread in C++11?",
    "options": [
      "Class representing thread of execution",
      "Thread class",
      "Concurrent thread",
      "Thread object"
    ],
    "correct": 0,
    "category": "Multithreading",
    "type": "single"
  },
  {
    "question": "How to pass arguments to thread?",
    "options": [
      "Pass after function in thread constructor",
      "Use std::bind",
      "Use lambda",
      "All of the above"
    ],
    "correct": 3,
    "category": "Multithreading",
    "type": "single"
  },
  {
    "question": "What is thread join?",
    "options": [
      "Wait for thread to complete",
      "Join threads",
      "Combine threads",
      "Connect threads"
    ],
    "correct": 0,
    "category": "Multithreading",
    "type": "single"
  },
  {
    "question": "What is thread detach?",
    "options": [
      "Separate thread to run independently",
      "Detach thread",
      "Remove thread",
      "Release thread"
    ],
    "correct": 0,
    "category": "Multithreading",
    "type": "single"
  },
  {
    "question": "What is std::mutex?",
    "options": [
      "Mutual exclusion for thread synchronization",
      "Mutex lock",
      "Thread mutex",
      "Mutual lock"
    ],
    "correct": 0,
    "category": "Multithreading",
    "type": "single"
  },
  {
    "question": "What is std::lock_guard?",
    "options": [
      "RAII wrapper for mutex",
      "Guard lock",
      "Lock guard",
      "Mutex guard"
    ],
    "correct": 0,
    "category": "Multithreading",
    "type": "single"
  },
  {
    "question": "What is std::unique_lock?",
    "options": [
      "Flexible RAII mutex wrapper",
      "Unique lock",
      "Lock unique",
      "Flexible lock"
    ],
    "correct": 0,
    "category": "Multithreading",
    "type": "single"
  },
  {
    "question": "What is deadlock?",
    "options": [
      "Two threads waiting for each other's locks",
      "Dead lock",
      "Lock dead",
      "Thread deadlock"
    ],
    "correct": 0,
    "category": "Multithreading",
    "type": "single"
  },
  {
    "question": "What is std::lock function?",
    "options": [
      "Lock multiple mutexes without deadlock",
      "Lock function",
      "Multi lock",
      "Lock all"
    ],
    "correct": 0,
    "category": "Multithreading",
    "type": "single"
  },
  {
    "question": "What is std::condition_variable?",
    "options": [
      "Synchronization primitive for thread waiting",
      "Condition variable",
      "Wait condition",
      "Thread condition"
    ],
    "correct": 0,
    "category": "Multithreading",
    "type": "single"
  },
  {
    "question": "What is spurious wakeup?",
    "options": [
      "Condition variable wakes without notify",
      "False wakeup",
      "Spurious wake",
      "Unexpected wake"
    ],
    "correct": 0,
    "category": "Multithreading",
    "type": "single"
  },
  {
    "question": "What is std::atomic?",
    "options": [
      "Lock-free atomic operations",
      "Atomic type",
      "Atomic variable",
      "Thread atomic"
    ],
    "correct": 0,
    "category": "Multithreading",
    "type": "single"
  },
  {
    "question": "What is memory order in atomics?",
    "options": [
      "Constraint on memory access ordering",
      "Memory ordering",
      "Order memory",
      "Atomic order"
    ],
    "correct": 0,
    "category": "Multithreading",
    "type": "single"
  },
  {
    "question": "What is memory_order_relaxed?",
    "options": [
      "No ordering constraints",
      "Relaxed order",
      "No order",
      "Free order"
    ],
    "correct": 0,
    "category": "Multithreading",
    "type": "single"
  },
  {
    "question": "What is memory_order_acquire?",
    "options": [
      "Synchronize with release",
      "Acquire order",
      "Get order",
      "Acquire memory"
    ],
    "correct": 0,
    "category": "Multithreading",
    "type": "single"
  },
  {
    "question": "What is memory_order_release?",
    "options": [
      "Synchronize with acquire",
      "Release order",
      "Free order",
      "Release memory"
    ],
    "correct": 0,
    "category": "Multithreading",
    "type": "single"
  },
  {
    "question": "What is memory_order_seq_cst?",
    "options": [
      "Sequential consistency",
      "Sequence order",
      "Sequential memory",
      "Consistent order"
    ],
    "correct": 0,
    "category": "Multithreading",
    "type": "single"
  },
  {
    "question": "What is std::future?",
    "options": [
      "Asynchronous result",
      "Future value",
      "Async future",
      "Result future"
    ],
    "correct": 0,
    "category": "Multithreading",
    "type": "single"
  },
  {
    "question": "What is std::promise?",
    "options": [
      "Set value for future",
      "Promise value",
      "Future promise",
      "Value promise"
    ],
    "correct": 0,
    "category": "Multithreading",
    "type": "single"
  },
  {
    "question": "What is std::async?",
    "options": [
      "Run function asynchronously",
      "Async function",
      "Asynchronous run",
      "Run async"
    ],
    "correct": 0,
    "category": "Multithreading",
    "type": "single"
  },
  {
    "question": "What is std::packaged_task?",
    "options": [
      "Wrap callable for async execution",
      "Package task",
      "Task package",
      "Packaged function"
    ],
    "correct": 0,
    "category": "Multithreading",
    "type": "single"
  },
  {
    "question": "What is thread_local storage?",
    "options": [
      "Thread-specific variable storage",
      "Local thread",
      "Thread variable",
      "Local storage"
    ],
    "correct": 0,
    "category": "Multithreading",
    "type": "single"
  },
  {
    "question": "What is data race?",
    "options": [
      "Concurrent unsynchronized access to data",
      "Race condition",
      "Data conflict",
      "Concurrent race"
    ],
    "correct": 0,
    "category": "Multithreading",
    "type": "single"
  },
  {
    "question": "What is race condition?",
    "options": [
      "Behavior depends on thread timing",
      "Race data",
      "Condition race",
      "Thread race"
    ],
    "correct": 0,
    "category": "Multithreading",
    "type": "single"
  },
  {
    "question": "What is std::shared_mutex in C++17?",
    "options": [
      "Multiple readers or one writer",
      "Shared mutex",
      "Multiple mutex",
      "Read mutex"
    ],
    "correct": 0,
    "category": "Multithreading",
    "type": "single"
  },
  {
    "question": "What is std::scoped_lock in C++17?",
    "options": [
      "Lock multiple mutexes with RAII",
      "Scoped lock",
      "Multi lock",
      "Scope mutex"
    ],
    "correct": 0,
    "category": "Multithreading",
    "type": "single"
  },
  {
    "question": "What is std::jthread in C++20?",
    "options": [
      "Thread with automatic join",
      "Join thread",
      "Auto thread",
      "Joining thread"
    ],
    "correct": 0,
    "category": "Multithreading",
    "type": "single"
  },
  {
    "question": "What is std::counting_semaphore in C++20?",
    "options": [
      "Semaphore for resource counting",
      "Count semaphore",
      "Semaphore count",
      "Resource semaphore"
    ],
    "correct": 0,
    "category": "Multithreading",
    "type": "single"
  },
  {
    "question": "What is std::latch in C++20?",
    "options": [
      "Single-use countdown synchronization",
      "Latch sync",
      "Countdown latch",
      "Sync latch"
    ],
    "correct": 0,
    "category": "Multithreading",
    "type": "single"
  },
  {
    "question": "What is std::barrier in C++20?",
    "options": [
      "Reusable thread synchronization point",
      "Thread barrier",
      "Sync barrier",
      "Barrier sync"
    ],
    "correct": 0,
    "category": "Multithreading",
    "type": "single"
  },
  {
    "question": "What is exception safety?",
    "options": [
      "Guarantee about program state after exception",
      "Safe exception",
      "Exception safe",
      "Safety exception"
    ],
    "correct": 0,
    "category": "Exceptions",
    "type": "single"
  },
  {
    "question": "What is basic exception guarantee?",
    "options": [
      "No resource leaks, object in valid state",
      "Basic safety",
      "Basic guarantee",
      "Simple exception"
    ],
    "correct": 0,
    "category": "Exceptions",
    "type": "single"
  },
  {
    "question": "What is strong exception guarantee?",
    "options": [
      "Operation succeeds or has no effect",
      "Strong safety",
      "Strong guarantee",
      "Complete exception"
    ],
    "correct": 0,
    "category": "Exceptions",
    "type": "single"
  },
  {
    "question": "What is nothrow guarantee?",
    "options": [
      "Operation never throws exception",
      "No throw",
      "Nothrow exception",
      "Never throw"
    ],
    "correct": 0,
    "category": "Exceptions",
    "type": "single"
  },
  {
    "question": "What is std::exception?",
    "options": [
      "Base class for standard exceptions",
      "Exception class",
      "Standard exception",
      "Base exception"
    ],
    "correct": 0,
    "category": "Exceptions",
    "type": "single"
  },
  {
    "question": "What is std::runtime_error?",
    "options": [
      "Runtime error exception",
      "Runtime exception",
      "Error runtime",
      "Run error"
    ],
    "correct": 0,
    "category": "Exceptions",
    "type": "single"
  },
  {
    "question": "What is std::logic_error?",
    "options": [
      "Logic error exception",
      "Logical exception",
      "Error logic",
      "Logic exception"
    ],
    "correct": 0,
    "category": "Exceptions",
    "type": "single"
  },
  {
    "question": "What is std::bad_alloc?",
    "options": [
      "Memory allocation failure exception",
      "Bad allocation",
      "Alloc error",
      "Memory bad"
    ],
    "correct": 0,
    "category": "Exceptions",
    "type": "single"
  },
  {
    "question": "What is std::bad_cast?",
    "options": [
      "Dynamic cast failure exception",
      "Bad cast",
      "Cast error",
      "Cast bad"
    ],
    "correct": 0,
    "category": "Exceptions",
    "type": "single"
  },
  {
    "question": "What is exception specifications?",
    "options": [
      "Deprecated syntax for specifying throwable exceptions",
      "Exception spec",
      "Throw spec",
      "Exception list"
    ],
    "correct": 0,
    "category": "Exceptions",
    "type": "single"
  },
  {
    "question": "What is noexcept specifier?",
    "options": [
      "Specify function won't throw",
      "No except",
      "Not throw",
      "Exception no"
    ],
    "correct": 0,
    "category": "Exceptions",
    "type": "single"
  },
  {
    "question": "What is noexcept operator?",
    "options": [
      "Check if expression is noexcept",
      "Noexcept check",
      "Check noexcept",
      "Operator noexcept"
    ],
    "correct": 0,
    "category": "Exceptions",
    "type": "single"
  },
  {
    "question": "What is std::current_exception?",
    "options": [
      "Capture current exception",
      "Current exception",
      "Exception current",
      "Get exception"
    ],
    "correct": 0,
    "category": "Exceptions",
    "type": "single"
  },
  {
    "question": "What is std::exception_ptr?",
    "options": [
      "Shared pointer to exception",
      "Exception pointer",
      "Pointer exception",
      "Exception ptr"
    ],
    "correct": 0,
    "category": "Exceptions",
    "type": "single"
  },
  {
    "question": "What is std::rethrow_exception?",
    "options": [
      "Rethrow exception from exception_ptr",
      "Rethrow",
      "Throw again",
      "Exception rethrow"
    ],
    "correct": 0,
    "category": "Exceptions",
    "type": "single"
  },
  {
    "question": "What is std::terminate?",
    "options": [
      "Called when exception handling fails",
      "Terminate program",
      "End program",
      "Program terminate"
    ],
    "correct": 0,
    "category": "Exceptions",
    "type": "single"
  },
  {
    "question": "What is std::set_terminate?",
    "options": [
      "Set terminate handler",
      "Set handler",
      "Terminate set",
      "Handler terminate"
    ],
    "correct": 0,
    "category": "Exceptions",
    "type": "single"
  },
  {
    "question": "What is std::unexpected?",
    "options": [
      "Deprecated exception spec violation handler",
      "Unexpected exception",
      "Exception unexpected",
      "Unexpected handler"
    ],
    "correct": 0,
    "category": "Exceptions",
    "type": "single"
  },
  {
    "question": "What is std::nested_exception?",
    "options": [
      "Wrap exception inside another",
      "Nested exception",
      "Exception nested",
      "Inner exception"
    ],
    "correct": 0,
    "category": "Exceptions",
    "type": "single"
  },
  {
    "question": "What is exception slicing?",
    "options": [
      "Loss of derived exception info when caught by base",
      "Slice exception",
      "Exception slice",
      "Slicing error"
    ],
    "correct": 0,
    "category": "Exceptions",
    "type": "single"
  },
  {
    "question": "What is #pragma once?",
    "options": [
      "Header guard alternative",
      "Pragma directive",
      "Once directive",
      "Header once"
    ],
    "correct": 0,
    "category": "Preprocessor",
    "type": "single"
  },
  {
    "question": "What is #error directive?",
    "options": [
      "Generate compilation error",
      "Error directive",
      "Compile error",
      "Directive error"
    ],
    "correct": 0,
    "category": "Preprocessor",
    "type": "single"
  },
  {
    "question": "What is #warning directive?",
    "options": [
      "Generate compilation warning",
      "Warning directive",
      "Compile warning",
      "Directive warning"
    ],
    "correct": 0,
    "category": "Preprocessor",
    "type": "single"
  },
  {
    "question": "What is __LINE__ macro?",
    "options": [
      "Current line number",
      "Line macro",
      "Macro line",
      "Number line"
    ],
    "correct": 0,
    "category": "Preprocessor",
    "type": "single"
  },
  {
    "question": "What is __FILE__ macro?",
    "options": [
      "Current filename",
      "File macro",
      "Macro file",
      "Name file"
    ],
    "correct": 0,
    "category": "Preprocessor",
    "type": "single"
  },
  {
    "question": "What is __func__ identifier?",
    "options": [
      "Current function name",
      "Function name",
      "Func identifier",
      "Name function"
    ],
    "correct": 0,
    "category": "Preprocessor",
    "type": "single"
  },
  {
    "question": "What is __DATE__ macro?",
    "options": [
      "Compilation date",
      "Date macro",
      "Macro date",
      "Date compile"
    ],
    "correct": 0,
    "category": "Preprocessor",
    "type": "single"
  },
  {
    "question": "What is __TIME__ macro?",
    "options": [
      "Compilation time",
      "Time macro",
      "Macro time",
      "Time compile"
    ],
    "correct": 0,
    "category": "Preprocessor",
    "type": "single"
  },
  {
    "question": "What is __cplusplus macro?",
    "options": [
      "C++ standard version",
      "C++ macro",
      "Version macro",
      "Standard macro"
    ],
    "correct": 0,
    "category": "Preprocessor",
    "type": "single"
  },
  {
    "question": "What is token pasting operator ##?",
    "options": [
      "Concatenate tokens",
      "Paste tokens",
      "Join tokens",
      "Merge tokens"
    ],
    "correct": 0,
    "category": "Preprocessor",
    "type": "single"
  },
  {
    "question": "What is stringification operator #?",
    "options": [
      "Convert macro argument to string",
      "Stringify",
      "String macro",
      "Macro string"
    ],
    "correct": 0,
    "category": "Preprocessor",
    "type": "single"
  },
  {
    "question": "What is variadic macro?",
    "options": [
      "Macro accepting variable arguments",
      "Variable macro",
      "Variadic arguments",
      "Macro variadic"
    ],
    "correct": 0,
    "category": "Preprocessor",
    "type": "single"
  },
  {
    "question": "What is __VA_ARGS__?",
    "options": [
      "Variadic macro arguments",
      "Variable arguments",
      "Variadic args",
      "Macro args"
    ],
    "correct": 0,
    "category": "Preprocessor",
    "type": "single"
  },
  {
    "question": "What is #include guard?",
    "options": [
      "Prevent multiple inclusion",
      "Include guard",
      "Header guard",
      "Multiple include"
    ],
    "correct": 0,
    "category": "Preprocessor",
    "type": "single"
  },
  {
    "question": "What is forward declaration?",
    "options": [
      "Declare identifier before definition",
      "Forward declare",
      "Declare forward",
      "Pre-declaration"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "What is alignof operator in C++11?",
    "options": [
      "Query alignment requirement of type",
      "Alignment of",
      "Align operator",
      "Of alignment"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is alignas specifier in C++11?",
    "options": [
      "Specify alignment requirement",
      "Align as",
      "As alignment",
      "Alignment specifier"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is std::launder in C++17?",
    "options": [
      "Obtain pointer to object in reused storage",
      "Launder pointer",
      "Clean pointer",
      "Refresh pointer"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is std::bit_cast in C++20?",
    "options": [
      "Reinterpret bits as different type",
      "Bit cast",
      "Cast bits",
      "Bits reinterpret"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is std::source_location in C++20?",
    "options": [
      "Get source code location info",
      "Source location",
      "Location source",
      "Code location"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is std::byte in C++17?",
    "options": [
      "Type representing byte of data",
      "Byte type",
      "Data byte",
      "Byte data"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is inline variable in C++17?",
    "options": [
      "Variable with inline linkage",
      "Inline var",
      "Variable inline",
      "Inline variable"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is inline namespace?",
    "options": [
      "Transparent namespace",
      "Inline namespace",
      "Namespace inline",
      "Transparent ns"
    ],
    "correct": 0,
    "category": "Namespaces",
    "type": "single"
  },
  {
    "question": "What is anonymous namespace?",
    "options": [
      "Internal linkage namespace",
      "Anonymous namespace",
      "Unnamed namespace",
      "Namespace anonymous"
    ],
    "correct": 0,
    "category": "Namespaces",
    "type": "single"
  },
  {
    "question": "What is namespace alias?",
    "options": [
      "Alternative name for namespace",
      "Alias namespace",
      "Namespace name",
      "Name alias"
    ],
    "correct": 0,
    "category": "Namespaces",
    "type": "single"
  },
  {
    "question": "What is using directive?",
    "options": [
      "Bring namespace members into scope",
      "Using namespace",
      "Directive using",
      "Namespace using"
    ],
    "correct": 0,
    "category": "Namespaces",
    "type": "single"
  },
  {
    "question": "What is using declaration?",
    "options": [
      "Bring specific member into scope",
      "Using declare",
      "Declaration using",
      "Using member"
    ],
    "correct": 0,
    "category": "Namespaces",
    "type": "single"
  },
  {
    "question": "What is incomplete type?",
    "options": [
      "Type declared but not defined",
      "Incomplete type",
      "Partial type",
      "Undefined type"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "What is ODR (One Definition Rule)?",
    "options": [
      "Entity defined exactly once across program",
      "One definition",
      "Definition rule",
      "Single definition"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "What is translation unit?",
    "options": [
      "Source file with includes",
      "Translation unit",
      "Compile unit",
      "Source unit"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "What is linkage in C++?",
    "options": [
      "Visibility of symbols across units",
      "Symbol linkage",
      "Link visibility",
      "Symbol link"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "What is internal linkage?",
    "options": [
      "Visible only in current translation unit",
      "Internal link",
      "Local linkage",
      "Unit linkage"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "What is external linkage?",
    "options": [
      "Visible across translation units",
      "External link",
      "Global linkage",
      "Cross linkage"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "What is name mangling?",
    "options": [
      "Encode function signature in symbol name",
      "Mangle name",
      "Name encoding",
      "Symbol mangle"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "What is extern \"C\"?",
    "options": [
      "Use C linkage (no name mangling)",
      "C linkage",
      "External C",
      "C extern"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "What is static assertion?",
    "options": [
      "Compile-time assertion",
      "Static assert",
      "Assert static",
      "Compile assert"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "What is std::initializer_list?",
    "options": [
      "List initialization type",
      "Initializer list",
      "List init",
      "Init list"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is aggregate type?",
    "options": [
      "Array or struct with no user-declared constructors",
      "Aggregate struct",
      "Type aggregate",
      "Aggregate class"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "What is POD (Plain Old Data)?",
    "options": [
      "C-compatible data type",
      "Plain data",
      "Old data",
      "Data type"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "What is trivial type?",
    "options": [
      "Type with trivial special members",
      "Trivial data",
      "Simple type",
      "Basic type"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "What is standard layout type?",
    "options": [
      "Type compatible with C layout",
      "Standard layout",
      "Layout type",
      "C layout"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "What is literal type?",
    "options": [
      "Type usable in constexpr",
      "Literal type",
      "Constant type",
      "Literal value"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is user-defined literal?",
    "options": [
      "Custom suffix for literals",
      "User literal",
      "Custom literal",
      "Defined literal"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is raw string literal?",
    "options": [
      "String without escape sequences R\\\"(...)\\\"",
      "Raw string",
      "Unescaped string",
      "Literal raw"
    ],
    "correct": 0,
    "category": "Strings",
    "type": "single"
  },
  {
    "question": "What is binary literal in C++14?",
    "options": [
      "0b prefix for binary",
      "Binary number",
      "Literal binary",
      "Binary value"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is copy constructor elision?",
    "options": [
      "Optimization avoiding copy constructor call",
      "Elide copy",
      "Copy optimization",
      "Constructor elision"
    ],
    "correct": 0,
    "category": "OOP",
    "type": "single"
  },
  {
    "question": "What is guaranteed copy elision in C++17?",
    "options": [
      "Mandatory elision in certain cases",
      "Guaranteed elision",
      "Must elide",
      "Required elision"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is zero-cost abstraction?",
    "options": [
      "Abstraction with no runtime overhead",
      "Zero cost",
      "Free abstraction",
      "No cost"
    ],
    "correct": 0,
    "category": "OOP",
    "type": "single"
  },
  {
    "question": "What is devirtualization?",
    "options": [
      "Optimization to avoid virtual function call",
      "Remove virtual",
      "Virtual optimization",
      "Devirtualize"
    ],
    "correct": 0,
    "category": "OOP",
    "type": "single"
  },
  {
    "question": "What is as-if rule?",
    "options": [
      "Compiler can optimize if observable behavior same",
      "As if rule",
      "Optimization rule",
      "Behavior rule"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "What is undefined behavior (UB)?",
    "options": [
      "Behavior not specified by standard",
      "Undefined behavior",
      "Unknown behavior",
      "Unspecified behavior"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "What is unspecified behavior?",
    "options": [
      "Multiple valid implementations",
      "Unspecified behavior",
      "Not specified",
      "Multiple behavior"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "What is implementation-defined behavior?",
    "options": [
      "Behavior specified by compiler",
      "Implementation defined",
      "Compiler defined",
      "Defined implementation"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "What is sequence point?",
    "options": [
      "Point where side effects complete",
      "Sequence point",
      "Effect point",
      "Side point"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "What is strict aliasing rule?",
    "options": [
      "Restrict pointer type aliasing",
      "Strict alias",
      "Aliasing rule",
      "Pointer aliasing"
    ],
    "correct": 0,
    "category": "Pointers",
    "type": "single"
  },
  {
    "question": "What is [[likely]] attribute in C++20?",
    "options": [
      "Hint for branch optimization",
      "Likely branch",
      "Optimization hint",
      "Branch likely"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is [[unlikely]] attribute in C++20?",
    "options": [
      "Hint for rare branch",
      "Unlikely branch",
      "Rare branch",
      "Branch unlikely"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is [[nodiscard]] attribute in C++17?",
    "options": [
      "Warn if return value ignored",
      "No discard",
      "Must use",
      "Return warning"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is the output: `int x = 5; cout << (++x * 2);`?",
    "options": [
      "12",
      "10",
      "11",
      "Undefined"
    ],
    "correct": 0,
    "category": "Operators",
    "type": "single",
    "code": "int x = 5;\ncout << (++x * 2);"
  },
  {
    "question": "What is the output: `int x = 5; cout << (x++ * 2);`?",
    "options": [
      "10",
      "12",
      "11",
      "Undefined"
    ],
    "correct": 0,
    "category": "Operators",
    "type": "single",
    "code": "int x = 5;\ncout << (x++ * 2);"
  },
  {
    "question": "What does `typeid` operator return?",
    "options": [
      "std::type_info reference",
      "Type name",
      "Type size",
      "Type pointer"
    ],
    "correct": 0,
    "category": "RTTI",
    "type": "single"
  },
  {
    "question": "What is RTTI in C++?",
    "options": [
      "Run-Time Type Information",
      "Real-Time Type Interface",
      "Runtime Type Implementation",
      "Reference Type Information"
    ],
    "correct": 0,
    "category": "RTTI",
    "type": "single"
  },
  {
    "question": "What is `dynamic_cast` used for?",
    "options": [
      "Safe downcasting in inheritance",
      "Type conversion",
      "Cast dynamic",
      "Runtime cast"
    ],
    "correct": 0,
    "category": "Type Casting",
    "type": "single"
  },
  {
    "question": "What happens if `dynamic_cast` fails with pointers?",
    "options": [
      "Returns nullptr",
      "Throws exception",
      "Undefined behavior",
      "Returns original pointer"
    ],
    "correct": 0,
    "category": "Type Casting",
    "type": "single"
  },
  {
    "question": "What happens if `dynamic_cast` fails with references?",
    "options": [
      "Throws std::bad_cast",
      "Returns null",
      "Undefined behavior",
      "Returns original reference"
    ],
    "correct": 0,
    "category": "Type Casting",
    "type": "single"
  },
  {
    "question": "What is `const_cast` used for?",
    "options": [
      "Add or remove const qualifier",
      "Cast constant",
      "Constant casting",
      "Make const"
    ],
    "correct": 0,
    "category": "Type Casting",
    "type": "single"
  },
  {
    "question": "What is `reinterpret_cast` used for?",
    "options": [
      "Low-level type reinterpretation",
      "Reinterpret type",
      "Cast reinterpret",
      "Type reinterpret"
    ],
    "correct": 0,
    "category": "Type Casting",
    "type": "single"
  },
  {
    "question": "Is `reinterpret_cast` portable?",
    "options": [
      "No, implementation-defined",
      "Yes, always",
      "Partially",
      "Depends"
    ],
    "correct": 0,
    "category": "Type Casting",
    "type": "single"
  },
  {
    "question": "What is function try block?",
    "options": [
      "try-catch around function body",
      "Function try",
      "Try function",
      "Block try"
    ],
    "correct": 0,
    "category": "Exceptions",
    "type": "single"
  },
  {
    "question": "Can we catch exceptions from member initializers?",
    "options": [
      "Yes, using function try block",
      "No",
      "Only in constructor",
      "Only in destructor"
    ],
    "correct": 0,
    "category": "Exceptions",
    "type": "single"
  },
  {
    "question": "What is exception safety in move operations?",
    "options": [
      "Move should be noexcept",
      "Move throws",
      "Move safe",
      "Exception move"
    ],
    "correct": 0,
    "category": "Exceptions",
    "type": "single"
  },
  {
    "question": "What is std::vector reallocation guarantee?",
    "options": [
      "Strong if move is noexcept, basic otherwise",
      "Always strong",
      "Always basic",
      "No guarantee"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "What is the output: `vector<int> v{10, 5};`? (size)",
    "options": [
      "2",
      "10",
      "15",
      "Compile error"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single",
    "code": "vector<int> v{10, 5};\ncout << v.size();"
  },
  {
    "question": "What is the output: `vector<int> v(10, 5);`? (size)",
    "options": [
      "10",
      "2",
      "5",
      "15"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single",
    "code": "vector<int> v(10, 5);\ncout << v.size();"
  },
  {
    "question": "What is iterator invalidation?",
    "options": [
      "Iterator becomes invalid after container modification",
      "Invalid iterator",
      "Iterator error",
      "Iterator fail"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "Do vector iterators invalidate on push_back?",
    "options": [
      "Yes if reallocation occurs",
      "Always yes",
      "Always no",
      "Never"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "Do list iterators invalidate on insertion?",
    "options": [
      "No",
      "Yes",
      "Sometimes",
      "Depends"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "What is the output: `cout << (true ? 1 : 2.5);`?",
    "options": [
      "1",
      "1.0",
      "Compile error",
      "2.5"
    ],
    "correct": 0,
    "category": "Operators",
    "type": "single",
    "code": "cout << (true ? 1 : 2.5);"
  },
  {
    "question": "What type is `true ? 1 : 2.5`?",
    "options": [
      "double",
      "int",
      "float",
      "auto"
    ],
    "correct": 0,
    "category": "Type Casting",
    "type": "single"
  },
  {
    "question": "What is std::chrono?",
    "options": [
      "Time library in C++11",
      "Chronological",
      "Time chrono",
      "Chrono time"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is std::chrono::duration?",
    "options": [
      "Represents time interval",
      "Duration time",
      "Time duration",
      "Interval duration"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is std::chrono::time_point?",
    "options": [
      "Point in time",
      "Time point",
      "Point time",
      "Time moment"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is std::ratio?",
    "options": [
      "Compile-time rational number",
      "Ratio type",
      "Rational number",
      "Number ratio"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is std::regex in C++11?",
    "options": [
      "Regular expression library",
      "Regex pattern",
      "Expression regex",
      "Pattern match"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is std::regex_match?",
    "options": [
      "Match entire string against pattern",
      "Match regex",
      "Regex check",
      "Pattern match"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is std::regex_search?",
    "options": [
      "Find pattern anywhere in string",
      "Search regex",
      "Regex find",
      "Pattern search"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is std::regex_replace?",
    "options": [
      "Replace matches with string",
      "Replace regex",
      "Regex substitute",
      "Pattern replace"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is std::smatch?",
    "options": [
      "Match results for string",
      "String match",
      "Match string",
      "String result"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is std::random in C++11?",
    "options": [
      "Random number generation library",
      "Random generator",
      "Number random",
      "Generate random"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is std::mt19937?",
    "options": [
      "Mersenne Twister PRNG",
      "Random generator",
      "MT generator",
      "Twister random"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is std::uniform_int_distribution?",
    "options": [
      "Uniform integer random distribution",
      "Int distribution",
      "Uniform random",
      "Integer uniform"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is std::normal_distribution?",
    "options": [
      "Gaussian/normal distribution",
      "Normal random",
      "Distribution normal",
      "Random normal"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is std::random_device?",
    "options": [
      "Non-deterministic random number generator",
      "Random device",
      "Device random",
      "Hardware random"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is the output: `int a = 5, b = 10; cout << (a, b);`?",
    "options": [
      "10",
      "5",
      "5 10",
      "Compile error"
    ],
    "correct": 0,
    "category": "Operators",
    "type": "single",
    "code": "int a = 5, b = 10;\ncout << (a, b);"
  },
  {
    "question": "What is comma operator in C++?",
    "options": [
      "Evaluates left, returns right",
      "Comma separator",
      "List operator",
      "Multiple operator"
    ],
    "correct": 0,
    "category": "Operators",
    "type": "single"
  },
  {
    "question": "What is the precedence of comma operator?",
    "options": [
      "Lowest",
      "Highest",
      "Medium",
      "Same as assignment"
    ],
    "correct": 0,
    "category": "Operators",
    "type": "single"
  },
  {
    "question": "What is std::tuple in C++11?",
    "options": [
      "Fixed-size heterogeneous container",
      "Tuple container",
      "Multiple container",
      "Heterogeneous tuple"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is std::get for tuple?",
    "options": [
      "Access tuple element by index",
      "Get tuple",
      "Tuple access",
      "Element get"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is std::tie?",
    "options": [
      "Create tuple of references",
      "Tie tuple",
      "Tuple tie",
      "Reference tuple"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is std::make_tuple?",
    "options": [
      "Create tuple from arguments",
      "Make tuple",
      "Tuple factory",
      "Create tuple"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is std::tuple_cat?",
    "options": [
      "Concatenate tuples",
      "Cat tuple",
      "Tuple concat",
      "Join tuples"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is std::pair?",
    "options": [
      "Container with two elements",
      "Pair container",
      "Two elements",
      "Double container"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "What is std::make_pair?",
    "options": [
      "Create pair from arguments",
      "Make pair",
      "Pair factory",
      "Create pair"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "What is aggregate in C++?",
    "options": [
      "Type that can use aggregate initialization",
      "Aggregate type",
      "Combined type",
      "Group type"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "Can aggregate have user-declared constructors?",
    "options": [
      "No",
      "Yes",
      "Only default",
      "Only copy"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "Can aggregate have private members?",
    "options": [
      "No (in C++17+)",
      "Yes",
      "Only static",
      "Only const"
    ],
    "correct": 0,
    "category": "Basics",
    "type": "single"
  },
  {
    "question": "What is std::iota?",
    "options": [
      "Fill range with incrementing values",
      "Iota function",
      "Fill range",
      "Increment fill"
    ],
    "correct": 0,
    "category": "STL",
    "type": "single"
  },
  {
    "question": "What is std::clamp in C++17?",
    "options": [
      "Constrain value between min and max",
      "Clamp value",
      "Value clamp",
      "Min max clamp"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is std::lerp in C++20?",
    "options": [
      "Linear interpolation",
      "Interpolate linear",
      "Lerp function",
      "Linear lerp"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is std::midpoint in C++20?",
    "options": [
      "Calculate midpoint without overflow",
      "Mid point",
      "Middle point",
      "Point middle"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is std::gcd in C++17?",
    "options": [
      "Greatest common divisor",
      "GCD function",
      "Common divisor",
      "Greatest divisor"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is std::lcm in C++17?",
    "options": [
      "Least common multiple",
      "LCM function",
      "Common multiple",
      "Least multiple"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is std::exchange in C++14?",
    "options": [
      "Replace value and return old value",
      "Exchange values",
      "Swap exchange",
      "Value exchange"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is std::as_const in C++17?",
    "options": [
      "Get const reference to object",
      "Make const",
      "As const",
      "Const reference"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is std::data in C++17?",
    "options": [
      "Get pointer to container data",
      "Data pointer",
      "Container data",
      "Get data"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is std::size in C++17?",
    "options": [
      "Get container size",
      "Size function",
      "Container size",
      "Get size"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is std::empty in C++17?",
    "options": [
      "Check if container empty",
      "Empty check",
      "Container empty",
      "Is empty"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is std::ssize in C++20?",
    "options": [
      "Get container size as signed",
      "Signed size",
      "Size signed",
      "Signed count"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is std::addressof in C++11?",
    "options": [
      "Get address even if operator& is overloaded",
      "Address function",
      "Get address",
      "Addressof operator"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is std::to_chars in C++17?",
    "options": [
      "Convert number to character sequence",
      "To characters",
      "Character conversion",
      "Chars to"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is std::from_chars in C++17?",
    "options": [
      "Parse number from character sequence",
      "From characters",
      "Character parsing",
      "Chars from"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  },
  {
    "question": "What is std::popcount in C++20?",
    "options": [
      "Count number of set bits",
      "Pop count",
      "Count population",
      "Bit count"
    ],
    "correct": 0,
    "category": "Modern C++",
    "type": "single"
  }
];

        let currentQuestion = 0;
        let userAnswers = Array(quizData.length).fill(null);
        let timeElapsed = 0;
        let timerInterval;
        let isTimerRunning = true;

        document.addEventListener('DOMContentLoaded', () => {
            const questionsContainer = document.getElementById('questions-container');
            const totalQuestionsCount = document.getElementById('total-questions-count');
            const currentQuestionIdx = document.getElementById('current-question-idx');
            const questionNav = document.getElementById('question-nav');
            const prevBtn = document.getElementById('prev-btn');
            const nextBtn = document.getElementById('next-btn');
            const submitBtn = document.getElementById('submit-btn');
            const timerEl = document.getElementById('timer');
            const toggleTimerBtn = document.getElementById('toggleTimer');
            const darkModeToggle = document.getElementById('darkModeToggle');
            const resultsContainer = document.getElementById('results-container');
            const quizBox = document.querySelector('.quiz-container');

            totalQuestionsCount.textContent = quizData.length;

            // Initialize Nav
            quizData.forEach((_, idx) => {
                const btn = document.createElement('button');
                btn.textContent = idx + 1;
                btn.onclick = () => goToQuestion(idx);
                questionNav.appendChild(btn);
            });

            function updateNav() {
                const btns = questionNav.querySelectorAll('button');
                btns.forEach((btn, idx) => {
                    btn.classList.remove('active', 'answered');
                    if (idx === currentQuestion) btn.classList.add('active');
                    else if (userAnswers[idx] !== null && userAnswers[idx] !== "") btn.classList.add('answered');
                });
            }

            function renderQuestion() {
                questionsContainer.innerHTML = '';
                const q = quizData[currentQuestion];
                currentQuestionIdx.textContent = currentQuestion + 1;

                const qDiv = document.createElement('div');
                qDiv.className = 'question-container active';
                
                const qText = document.createElement('div');
                qText.className = 'question';
                qText.innerHTML = (currentQuestion + 1) + '. ' + formatQuestionText(q.question) + 
                                  `<span class="category-badge">${q.category}</span>`;
                qDiv.appendChild(qText);

                const optionsDiv = document.createElement('div');
                optionsDiv.className = 'options';

                if (q.type === 'shortanswer' || q.options.length === 0) {
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.className = 'short-answer-input';
                    input.placeholder = 'Type your answer here...';
                    input.value = userAnswers[currentQuestion] || '';
                    input.oninput = (e) => {
                        userAnswers[currentQuestion] = e.target.value;
                        updateNav();
                    };
                    optionsDiv.appendChild(input);
                } else {
                    q.options.forEach((opt, idx) => {
                        const optDiv = document.createElement('div');
                        optDiv.className = 'option';
                        if (q.type === 'multiple') {
                            if (Array.isArray(userAnswers[currentQuestion]) && userAnswers[currentQuestion].includes(idx)) {
                                optDiv.classList.add('selected');
                            }
                        } else {
                            if (userAnswers[currentQuestion] === idx) optDiv.classList.add('selected');
                        }

                        const input = document.createElement('input');
                        input.type = q.type === 'multiple' ? 'checkbox' : 'radio';
                        input.name = 'question-' + currentQuestion;
                        input.checked = q.type === 'multiple' ? 
                            (Array.isArray(userAnswers[currentQuestion]) && userAnswers[currentQuestion].includes(idx)) :
                            (userAnswers[currentQuestion] === idx);
                        
                        input.onclick = (e) => e.stopPropagation();
                        input.onchange = () => selectOption(idx);

                        optDiv.onclick = () => selectOption(idx);
                        
                        optDiv.appendChild(input);
                        const label = document.createElement('span');
                        label.textContent = opt;
                        optDiv.appendChild(label);
                        optionsDiv.appendChild(optDiv);
                    });
                }

                qDiv.appendChild(optionsDiv);
                
                // Add Check Answer button
                const checkBtn = document.createElement('button');
                checkBtn.className = 'check-answer-btn';
                checkBtn.textContent = ' Check Answer';
                checkBtn.onclick = () => checkAnswer(currentQuestion);
                qDiv.appendChild(checkBtn);
                
                // Add feedback container
                const feedbackDiv = document.createElement('div');
                feedbackDiv.className = 'answer-feedback';
                feedbackDiv.id = 'answer-feedback-' + currentQuestion;
                qDiv.appendChild(feedbackDiv);
                
                questionsContainer.appendChild(qDiv);

                prevBtn.disabled = currentQuestion === 0;
                nextBtn.disabled = currentQuestion === quizData.length - 1;
                updateNav();
            }
            
            function checkAnswer(qIndex) {
                const q = quizData[qIndex];
                const feedbackDiv = document.getElementById('answer-feedback-' + qIndex);
                const checkBtn = document.querySelector('.check-answer-btn');
                
                if (!feedbackDiv) return;
                
                let isCorrect = false;
                let userAns = userAnswers[qIndex];
                
                // Check if answer is provided
                if (userAns === null || userAns === '' || (Array.isArray(userAns) && userAns.length === 0)) {
                    feedbackDiv.innerHTML = '<strong> Please select an answer first!</strong>';
                    feedbackDiv.className = 'answer-feedback show incorrect';
                    return;
                }
                
                // Check correctness based on question type
                if (q.type === 'multiple') {
                    const correctAnswers = Array.isArray(q.correct) ? q.correct : [q.correct];
                    isCorrect = Array.isArray(userAns) && 
                               userAns.length === correctAnswers.length &&
                               userAns.every(a => correctAnswers.includes(a));
                } else {
                    isCorrect = userAns === q.correct;
                }
                
                // Display feedback
                let feedbackHTML = '';
                if (isCorrect) {
                    feedbackHTML = '<strong> Correct!</strong>';
                    feedbackDiv.className = 'answer-feedback show correct';
                } else {
                    const correctOpt = Array.isArray(q.correct) ? 
                        q.correct.map(i => q.options[i]).join(', ') : 
                        q.options[q.correct];
                    feedbackHTML = '<strong> Incorrect</strong>';
                    feedbackHTML += '<div style="margin-top: 8px;">Correct answer: <strong>' + correctOpt + '</strong></div>';
                    feedbackDiv.className = 'answer-feedback show incorrect';
                }
                
                feedbackDiv.innerHTML = feedbackHTML;
                checkBtn.textContent = ' Answer Checked';
                checkBtn.classList.add('checked');
            }

            function formatQuestionText(text) {
                // Preserve code formatting - detect code blocks in questions
                const hasCode = text.match(/cout|cin|#include|int |char |float |double |arr\[|[{};]|->|\*p|<<|>>/);
                
                if (hasCode) {
                    // Check if multiple code statements
                    const hasSemicolons = (text.match(/;/g) || []).length > 1;
                    const hasNewlines = text.includes('\n');
                    
                    // Split code from regular text by looking for code patterns
                    const codePattern = /((?:int|char|float|double|void|class|struct|#include|using namespace|std::)[^?!.]*?;(?:\s*(?:int|char|float|double|void|class|struct|cout|cin)[^?!.]*?;)*)/gi;
                    
                    if (hasSemicolons) {
                        // Multiple statements: format as code block
                        text = text.replace(codePattern, (match) => {
                            // Insert line breaks after semicolons for readability
                            let formatted = match.replace(/;\s*/g, ';<br>');
                            return '<pre><code>' + formatted + '</code></pre>';
                        });
                    } else {
                        // Single statement: use inline code
                        text = text.replace(codePattern, '<code>$1</code>');
                    }
                    
                    // Also handle standalone code expressions without semicolons
                    text = text.replace(/\b(cout\s*<<[^<]*(?:<<[^<]*)*|cin\s*>>[^>]*(?:>>[^>]*)*)/gi, '<code>$1</code>');
                    
                    // Handle array/pointer syntax
                    text = text.replace(/(\w+\s*\[\s*\d*\s*\]\s*=\s*\{[^}]+\})/g, '<code>$1</code>');
                    
                    // Replace newlines with breaks
                    text = text.replace(/\n/g, '<br>');
                    
                    // Clean up double-wrapped tags
                    text = text.replace(/<code>\s*<code>/g, '<code>');
                    text = text.replace(/<\/code>\s*<\/code>/g, '</code>');
                    text = text.replace(/<pre><code>\s*<pre><code>/g, '<pre><code>');
                    text = text.replace(/<\/code><\/pre>\s*<\/code><\/pre>/g, '</code></pre>');
                }
                
                return text;
            }

            function selectOption(idx) {
                const q = quizData[currentQuestion];
                if (q.type === 'multiple') {
                    if (!Array.isArray(userAnswers[currentQuestion])) userAnswers[currentQuestion] = [];
                    const foundIdx = userAnswers[currentQuestion].indexOf(idx);
                    if (foundIdx > -1) userAnswers[currentQuestion].splice(foundIdx, 1);
                    else userAnswers[currentQuestion].push(idx);
                } else {
                    userAnswers[currentQuestion] = idx;
                }
                renderQuestion();
            }

            function goToQuestion(idx) {
                currentQuestion = idx;
                renderQuestion();
                document.getElementById('question-nav').children[idx].scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }

            prevBtn.onclick = () => { if (currentQuestion > 0) goToQuestion(currentQuestion - 1); };
            nextBtn.onclick = () => { if (currentQuestion < quizData.length - 1) goToQuestion(currentQuestion + 1); };

            submitBtn.onclick = showResults;

            function showResults() {
                clearInterval(timerInterval);
                let score = 0;
                let resultsHTML = '';

                quizData.forEach((q, idx) => {
                    let isCorrect = false;
                    const userAns = userAnswers[idx];
                    
                    if (q.type === 'multiple') {
                        if (Array.isArray(userAns) && Array.isArray(q.correct)) {
                            isCorrect = userAns.length === q.correct.length && 
                                        userAns.every(val => q.correct.includes(val));
                        }
                    } else if (q.type === 'shortanswer') {
                        isCorrect = String(userAns).trim().toLowerCase() === String(q.correct).trim().toLowerCase();
                    } else {
                        isCorrect = userAns === q.correct;
                    }

                    if (isCorrect) score++;

                    resultsHTML += `
                        <div class="result-item ${isCorrect ? 'correct' : 'incorrect'}">
                            <div class="result-question">Question ${idx + 1}: ${q.question}</div>
                            <div class="result-answer">
                                Your answer: <span class="${isCorrect ? 'result-correct' : 'result-incorrect'}">
                                    ${formatUserAnswer(userAns, q)} ${isCorrect ? '' : ''}
                                </span>
                            </div>
                            ${!isCorrect ? `<div class="result-answer">Correct answer: <span class="result-correct">${formatUserAnswer(q.correct, q)}</span></div>` : ''}
                        </div>
                    `;
                });

                const percentage = Math.round((score / quizData.length) * 100);
                document.getElementById('score').textContent = `Your Score: ${score} / ${quizData.length} (${percentage}%)`;
                document.getElementById('results-list').innerHTML = resultsHTML;
                resultsContainer.classList.add('active');
                quizBox.style.display = 'none';
                window.scrollTo(0, 0);
            }

            function formatUserAnswer(ans, q) {
                if (ans === null || ans === undefined || ans === "") return "No answer";
                if (q.type === 'multiple') {
                    return Array.isArray(ans) ? ans.map(i => q.options[i]).join(', ') : ans;
                }
                if (q.type === 'shortanswer') return ans;
                return q.options[ans] || ans;
            }

            // Timer
            function startTimer() {
                timerInterval = setInterval(() => {
                    if (isTimerRunning) {
                        timeElapsed++;
                        const mins = Math.floor(timeElapsed / 60).toString().padStart(2, '0');
                        const secs = (timeElapsed % 60).toString().padStart(2, '0');
                        timerEl.textContent = `${mins}:${secs}`;
                    }
                }, 1000);
            }

            toggleTimerBtn.onclick = () => {
                isTimerRunning = !isTimerRunning;
                toggleTimerBtn.textContent = isTimerRunning ? 'Pause' : 'Resume';
            };

            darkModeToggle.onclick = () => {
                document.body.classList.toggle('dark-mode');
            };

            document.getElementById('retake-btn').onclick = () => {
                location.reload();
            };

            startTimer();
            renderQuestion();
        });
    </script>
</body>
</html>